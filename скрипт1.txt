{\rtf1\ansi\ansicpg1251\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh17440\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class Filler : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 //public bool StartEmpty;
\f1 \

\f0 \'a0\'a0\'a0 [Range(0, 1.0f)] public float StartFillPercent;
\f1 \

\f0 \'a0\'a0\'a0 public float TriggerTime = 0.2f;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private float Hat = 0.0f;
\f1 \

\f0 \'a0\'a0\'a0 //private float Factor = 13.543f;//making real size
\f1 \

\f0 \'a0\'a0\'a0 private float a = 0.75f;
\f1 \

\f0 \'a0\'a0\'a0 private float FillOffset = 0.51f;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float CurrentVolume;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float S;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float VesselHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float MaxVolume;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private Renderer rend;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private bool IsPouring;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float ActualHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private float VolPerDrop;
\f1 \

\f0 \'a0\'a0\'a0\'a0 private bool IsEmpty;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 private enum FunctionControlls \{ Start, Stop \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public float GetFillPercent() => CurrentVolume / MaxVolume;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public float GetVolume() => CurrentVolume;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Fill(float volume)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 if ((IsEmpty == true) && (volume != 0))
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IsEmpty = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.parent.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 float h;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 CurrentVolume += volume;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 CurrentVolume = Mathf.Clamp(CurrentVolume, 0, MaxVolume);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 h = CurrentVolume / MaxVolume;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ActualHeight = h;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 private void Pouring(FunctionControlls Control)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 ParticleSystem PS = transform.parent.GetChild(1).GetComponent<ParticleSystem>();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 var emission = PS.emission;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 //logic
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 if (Control == FunctionControlls.Start)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 emission.enabled = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IsPouring = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 else if (Control == FunctionControlls.Stop)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 emission.enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IsPouring = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 emission.enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IsPouring = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 private void EnableCollider()
\f1 \

\f0 \'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 GetComponent<CapsuleCollider>().enabled = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void DisableCollider()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GetComponent<CapsuleCollider>().enabled = false;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 VolPerDrop = transform.parent.GetChild(1).GetComponent<LiquidCore_v1>().VolumePerDrop;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 rend = GetComponent<Renderer>();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 VesselHeight = rend.bounds.size.y;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 S = Mathf.PI * Mathf.Pow(rend.bounds.size.x / 2, 2);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 MaxVolume = 1f / 3f * S * VesselHeight;//* Factor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Debug.Log(MaxVolume + " of " + transform.parent.name);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 CurrentVolume = StartFillPercent * MaxVolume;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (transform.parent.tag)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case "Cylinder":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a = 0.8f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 1.71f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 0.62f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case "Flask":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a = 1.3f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 1f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case "Beaker":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0a = 0.85f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 1.02f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 0.33f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case "Tube":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a = 0.8f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 0.5f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 1.2f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0case "Bottle":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a = 2f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 1.1f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 0.01f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case "Funnel":
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a = 0.5f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FillOffset = 0.5f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Hat = 0.01f;
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 Fill(0);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void Awake()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 // pouring fix
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GetComponent<CapsuleCollider>().contactOffset = 0.3f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GetComponentInParent<MeshCollider>().contactOffset = 0.4f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var col = transform.parent.GetChild(1).GetComponent<ParticleSystem>().collision;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 col.radiusScale = 0.5f;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 float angle, cos, AmountToDisplay;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 //emptyness check
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 if (CurrentVolume <= 0 && IsEmpty == false)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IsEmpty = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.parent.GetChild(1).GetComponent<LiquidCore_v1>().SetEmpty();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ActualHeight = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.parent.GetComponent<contain>().inVessel.Clear();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.parent.GetComponent<acidity>().Empty();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 angle = Vector3.Angle(transform.up, Vector3.up);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 cos = Mathf.Cos(angle * Mathf.PI / 180);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //display fix
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 AmountToDisplay = -VesselHeight * a * Mathf.Pow(ActualHeight, (2f - angle / 180) / 2.5f) + 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 (90 - angle) / 90 * FillOffset + (VesselHeight + Hat) * a * angle / 180;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //\'a0\'a0 AmountToDisplay = (90 - angle) / 90 * (FillOffset - ( VesselHeight * a * CurrentVolume/MaxVolume ) );
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rend.material.SetFloat("_FillAmount", AmountToDisplay);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (IsEmpty == false)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if ((cos * (VesselHeight)) <= -(ActualHeight - FillOffset))
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 DisableCollider();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (IsPouring == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Fill(VolPerDrop * transform.parent.GetChild(1).GetComponent<ParticleSystem>().emission.rateOverTime.constant * 2 * Time.deltaTime * -1);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Pouring(FunctionControlls.Start);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Invoke("EnableCollider", TriggerTime);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (IsPouring == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Pouring(FunctionControlls.Stop);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Stop");
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Invoke("EnableCollider", TriggerTime);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Pouring(FunctionControlls.Stop);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class LiquidCore_v1 : MonoBehaviour \{
\f1 \

\f0 \'a0\'a0\'a0 private Renderer rend;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 [Header("Properties")]
\f1 \

\f0 \'a0\'a0\'a0 public string Name;
\f1 \

\f0 \'a0\'a0\'a0 public string Type;
\f1 \

\f0 \'a0\'a0\'a0 public Material DefaultMat;
\f1 \

\f0 \'a0\'a0\'a0 public Material DefaultParticleMat;
\f1 \

\f0 \'a0\'a0\'a0 public float VolumePerDrop;
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 public Color StartColor;
\f1 \

\f0 \'a0\'a0\'a0 private Color TransparentColor = new Color(255, 255, 255, 0);
\f1 \

\f0 \'a0\'a0\'a0 private List<ParticleCollisionEvent> CollEvents;
\f1 \

\f0 \'a0\'a0\'a0 public static float addedC, addedV;
\f1 \

\f0 \'a0\'a0\'a0 public static string added, curVessel;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void SetUpMaterial()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Material matp , matl;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 matl = new Material(DefaultMat);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 matp = new Material(DefaultParticleMat);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 matp.color = StartColor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gameObject.GetComponent<ParticleSystemRenderer>().trailMaterial = matp;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (rend != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 matl.SetColor("_Tint", StartColor);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rend.material = matl;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void SetEmpty()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Name = "NONE";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Material matl;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 matl = new Material(DefaultMat);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 matl.SetColor("_Tint", TransparentColor);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rend.material = matl;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Invoke("DisablePS", 1);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void DisablePS()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 gameObject.GetComponent<ParticleSystemRenderer>().trailMaterial.color = TransparentColor;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 void Start () \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 CollEvents = new List<ParticleCollisionEvent>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (transform.parent != null) rend = transform.parent.GetChild(0).GetComponent<Renderer>();\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void OnParticleCollision(GameObject other)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int i = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("PrtCol");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int numCollisionEvents = GetComponent<ParticleSystem>().GetCollisionEvents(other, CollEvents);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 while (i < numCollisionEvents)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (CollEvents[i].colliderComponent.GetComponent<Filler>())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 other.GetComponentInChildren<Filler>().Fill(VolumePerDrop);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Destroy(GetComponent<ParticleSystem>().GetParticles[i]);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 added = transform.GetComponent<LiquidCore_v1>().Type;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 addedC = transform.GetComponentInParent<acidity>().startC;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 addedV = transform.GetComponent<LiquidCore_v1>().VolumePerDrop;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (CollEvents[i].colliderComponent.gameObject.transform.parent.tag == "Funnel")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CollEvents[i].colliderComponent.transform.parent.GetChild(1).GetComponent<LiquidCore_v1>().Type = added;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0CollEvents[i].colliderComponent.transform.GetComponentInParent<acidity>().startC = addedC;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CollEvents[i].colliderComponent.gameObject.transform.parent.GetComponent<contain>().Add();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CollEvents[i].colliderComponent.gameObject.transform.parent.GetComponent<acidity>().Reaction();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (CollEvents[i].colliderComponent.gameObject.transform.parent.GetComponent<indicators>() != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CollEvents[i].colliderComponent.gameObject.transform.parent.GetComponent<indicators>().done = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 i++;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class acidity : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public float startV, startC, pH, addedV, addedC;
\f1 \

\f0 \'a0\'a0\'a0 public string thisSub, addedSub;
\f1 \

\f0 \'a0\'a0\'a0 private float curCH, curCOH;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = transform.GetChild(0).GetComponent<Filler>().GetFillPercent();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 thisSub = transform.GetChild(1).GetComponent<LiquidCore_v1>().Type;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (thisSub == "HCl" || thisSub == "H2O") pH = Mathf.Log10(startC) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (thisSub == "NaOH") pH = Mathf.Log10(Mathf.Pow(10, -14) / startC) * (-1);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Reaction()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 addedSub = LiquidCore_v1.added;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 addedV = LiquidCore_v1.addedV;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 addedC = LiquidCore_v1.addedC;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (startV == 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0thisSub = addedSub;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = addedC;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = addedV;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (thisSub == "HCl" || thisSub == "H2O")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(startC) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(thisSub == "NaOH")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(Mathf.Pow(10, -14) / startC) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #region HCl;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (thisSub == "HCl" || thisSub == "H2O")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (addedSub == "NaOH")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0curCH = startC * (startV / startV + addedV);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCOH = addedC * (addedV / startV + addedV);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float b = curCH + curCOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float D = Mathf.Pow(b, 2) - 4 * (curCH * curCOH - Mathf.Pow(10, -14));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float x = (b - Mathf.Pow(D, 0.5f)) / 2;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCH = curCH - x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCOH = curCOH - x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(curCH) * (-1);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = startV + addedV;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if (pH <= 7)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = curCH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = Mathf.Pow(10, -14) / curCH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 thisSub = "NaOH";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCH = (startC * startV + addedC * addedV) / (startV + addedV);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(curCH) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = curCH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = startV + addedV;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endregion;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #region NaOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (thisSub == "NaOH" || thisSub == "H2O")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (addedSub == "HCl")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCOH = startC * (startV / startV + addedV);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCH = addedC * (addedV / startV + addedV);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float b = curCH + curCOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float D = Mathf.Pow(b, 2) - 4 * (curCH * curCOH - Mathf.Pow(10, -14));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float x = (b - Mathf.Pow(D, 0.5f)) / 2;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCH = curCH - x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCOH = curCOH - x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(Mathf.Pow(10, -14) / curCOH) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = startV + addedV;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH >= 7)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = curCOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0startC = Mathf.Pow(10, -14) / curCOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 thisSub = "HCl";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 //dilution
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curCOH = (startC * startV + addedC * addedV) / (startV + addedV);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = Mathf.Log10(Mathf.Pow(10, -14) / curCOH) * (-1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startC = curCOH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = startV + addedV;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endregion;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Empty()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 startV = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 thisSub = "-";
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class camera360 : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private GameObject thisCamera;
\f1 \

\f0 \'a0\'a0\'a0 public float speed = 10f;
\f1 \

\f0 \'a0\'a0\'a0 public float angleY, angleX;
\f1 \

\f0 \'a0\'a0\'a0 private float time, rot;
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 thisCamera = this.gameObject;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime * speed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rot = angleY + time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (angleY >= 180) angleY = 180;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.transform.localRotation = Quaternion.Euler(angleX, rot, 0);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class cameraMovement : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public float speed = 1f;
\f1 \

\f0 \'a0\'a0\'a0 private float posX, posY, posZ;
\f1 \

\f0 \'a0\'a0\'a0 private float time, mov;
\f1 \

\f0 \'a0\'a0\'a0 public string movAxis, movDir;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 posX = transform.position.x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 posY = transform.position.y;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 posZ = transform.position.z;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime * speed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (movDir == "+")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mov = time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(movDir == "-")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mov = -time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (movAxis == "x" || movAxis == "X")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localPosition = new Vector3 (posX + mov, posY, posZ);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (movAxis == "y" || movAxis == "Y")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localPosition = new Vector3(posX, posY + mov, posZ);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (movAxis == "z" || movAxis == "Z")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localPosition = new Vector3(posX, posY, posZ + mov);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class connect : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private GameObject lHand, rHand;
\f1 \

\f0 \'a0\'a0\'a0 public string connectTo;
\f1 \

\f0 \'a0\'a0\'a0 public Vector3 pos;
\f1 \

\f0 \'a0\'a0\'a0 public float rotX, rotY, rotZ;
\f1 \

\f0 \'a0\'a0\'a0 private bool connected, KM = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (GameObject.Find("PlayerVR") != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 lHand = GameObject.Find("PlayerVR").transform.Find("Controller (left)").gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand = GameObject.Find("PlayerVR").transform.Find("Controller (right)").gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand = GameObject.Find("PlayerKM").transform.GetChild(0).GetChild(0).gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(rHand.name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 lHand = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 KM = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 private void OnTriggerEnter(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(col.tag == connectTo && connected == false)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (KM == false)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 lHand.GetComponent<hand>().Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 lHand.GetComponent<hand>().m_ContactInteractables.Remove(transform.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand.GetComponent<hand>().Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand.GetComponent<hand>().m_ContactInteractables.Remove(transform.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand.GetComponent<handKM>().Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0rHand.GetComponent<handKM>().m_ContactInteractables.Remove(transform.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Destroy(transform.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Destroy(transform.GetComponent<Rigidbody>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0Destroy(col.GetComponent<SphereCollider>());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.SetParent(col.transform);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localPosition = pos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localRotation = Quaternion.Euler(rotX, rotY, rotZ);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 connected = true;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class contain : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public List<string> inVessel;
\f1 \

\f0 \'a0\'a0\'a0 private float time;
\f1 \

\f0 \'a0\'a0\'a0 private bool zero, done = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 inVessel.Add(transform.GetChild(1).GetComponent<LiquidCore_v1>().Type);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!done && inVessel.Contains("AgNO3") && inVessel.Contains("NaCl"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!zero)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 time = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 zero = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float ratio = time / 2;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color curCol = transform.Find("inner").GetComponent<Renderer>().material.GetColor("_Tint");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (time <= 2)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(curCol.r, curCol.g, curCol.b, ratio);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.Find("inner").GetComponent<Renderer>().material.SetColor("_Tint", newCol);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Add()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!inVessel.Contains(LiquidCore_v1.added))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 inVessel.Add(LiquidCore_v1.added);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class fire : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float rotX = -transform.parent.rotation.eulerAngles.x;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localRotation = Quaternion.Euler(rotX, 0, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //if (transform.localRotation.eulerAngles.x >= 80 || transform.localRotation.eulerAngles.x <= -80)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 //Destroy(transform.gameObject);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class fluorescence : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private List<string> inVessel;
\f1 \

\f0 \'a0\'a0\'a0 private bool done, check, zero;
\f1 \

\f0 \'a0\'a0\'a0 private float time;
\f1 \

\f0 \'a0\'a0\'a0 private Material mat;
\f1 \

\f0 \'a0\'a0\'a0 private Color def;
\f1 \

\f0 \'a0\'a0\'a0 public GameObject light1, light2, light3;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 inVessel = transform.GetComponent<contain>().inVessel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 check = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 zero = false;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (inVessel.Contains("Luciferase") && done == false)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!check)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mat = transform.GetChild(0).GetComponent<Renderer>().material;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 def = transform.GetChild(0).GetComponent<Renderer>().material.GetColor("_Tint");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 time = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 check = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float ratio = time / 2;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color fluor = new Color(0.2503115f, 0.6851759f, 0.7075471f, 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color change = Color.Lerp(def, fluor, ratio);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = change;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (time >= 2)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (done == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!zero)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetComponent<AudioSource>().Play();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 time = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 zero = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (time <= 1.2)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light1.GetComponent<Light>().intensity = 1.2f - time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light2.GetComponent<Light>().intensity = 1.2f - time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light3.GetComponent<Light>().intensity = 1.2f - time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if(time >= 20 && time <= 20 + 1.2)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (zero)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 time = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 zero = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light1.GetComponent<Light>().intensity += time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light2.GetComponent<Light>().intensity += time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 light3.GetComponent<Light>().intensity += time;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class indicators : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private List<string> inVessel;
\f1 \

\f0 \'a0\'a0\'a0 private float pH, time;
\f1 \

\f0 \'a0\'a0\'a0 public bool done;
\f1 \

\f0 \'a0\'a0\'a0 private bool zero = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 inVessel = transform.GetComponent<contain>().inVessel;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 pH = transform.GetComponent<acidity>().pH;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (inVessel.Contains("methylOrange") && !done)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color curCol = transform.Find("inner").GetComponent<Renderer>().material.GetColor("_Tint");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH <= 6)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(0.9f, 0.3f, 0.37f, 0.3f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = newCol;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH >= 8)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(0.89f, 0.84f, 0.29f, 0.3f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = newCol;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH >= 6 && pH <= 8)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(0.95f, 0.54f, 0.1f, 0.3f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = newCol;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (inVessel.Contains("PP") && !done)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color curCol = transform.Find("inner").GetComponent<Renderer>().material.GetColor("_Tint");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH >= 8)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(0.97f, 0.52f, 0.8f, 0.3f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = newCol;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (pH <= 8)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newCol = new Color(1f, 1f, 1f, 0.3f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().StartColor = newCol;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetChild(1).GetComponent<LiquidCore_v1>().SetUpMaterial();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 done = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.UI;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class buttonScript : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public Button but;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 but = GetComponent<Button>();
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Pressed()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 but.onClick.Invoke();
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class buttons_Fluor : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public void Menu()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("StartScene");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Again()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("FluorRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 using UnityEngine.UI;
\f1 \

\f0 \'a0
\f1 \

\f0 public class buttons_Ind : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject intro, testPan;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0intro.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 testPan.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Menu()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("StartScene");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Again()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("IndicatorRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Test()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 testPan.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 intro.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Right()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetComponent<Image>().material = Resources.Load("Green") as Material;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 public void Wrong()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetComponent<Image>().material = Resources.Load("Red") as Material;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class buttons_Sol : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public void Menu()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("StartScene");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Again()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("SolutionsRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class buttons_Start : MonoBehaviour
\f1 \

\f0 \{ 
\f1 \

\f0 \'a0\'a0\'a0 public void FluorRoom()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("FluorRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void LatticeRoom()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("LatticeRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void IndRoom()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("IndicatorRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void HRoom()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("HRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class button_H : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public void Menu()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("StartScene");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Again()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.LoadScene("HRoom");
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class CuO : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private Material oxideCol;
\f1 \

\f0 \'a0\'a0\'a0 public Material copperCol;
\f1 \

\f0 \'a0\'a0\'a0 private bool inArea = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private float time;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 oxideCol = transform.GetComponent<MeshRenderer>().material;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (inArea)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 time += Time.deltaTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0float ratio = time / 10;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Color newColor = Color.Lerp(oxideCol.color, copperCol.color, ratio);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.GetComponent<MeshRenderer>().material.color = newColor;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void OnTriggerEnter(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (col.tag == "Fire")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 inArea = true;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void OnTriggerExit(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (col.tag == "Fire")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 inArea = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class HExit : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 void OnTriggerEnter(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(col.tag == "Tube" && !col.GetComponent<contain>().inVessel.Contains("H2"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 col.GetComponent<contain>().inVessel.Add("H2");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class HTrig : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject CuO;
\f1 \

\f0 \'a0\'a0\'a0 public GameObject HExit;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ps = transform.Find("Gas").GetComponent<ParticleSystem>().emission;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ps.enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 CuO.GetComponent<SphereCollider>().enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 HExit.GetComponent<SphereCollider>().enabled = false;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (transform.GetComponent<contain>().inVessel.Contains("HCl"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ps = transform.Find("Gas").GetComponent<ParticleSystem>().emission;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ps.enabled = true;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (transform.Find("Bung") != null && transform.parent.parent.tag == "Holder")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("ok");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CuO.GetComponent<SphereCollider>().enabled = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 HExit.GetComponent<SphereCollider>().enabled = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class filler : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject playerCamera;
\f1 \

\f0 \'a0\'a0\'a0 public static float globalVolume;
\f1 \

\f0 \'a0\'a0\'a0 public Transform grabbedObj;
\f1 \

\f0 \'a0\'a0\'a0 public string liquidType;
\f1 \

\f0 \'a0\'a0\'a0 private bool planeVis, filling = false;
\f1 \

\f0 \'a0\'a0\'a0 public bool empty = true;
\f1 \

\f0 \'a0\'a0\'a0 private string volumeStr;
\f1 \

\f0 \'a0\'a0\'a0 private int volumeInt;
\f1 \

\f0 \'a0\'a0\'a0 public float volume;
\f1 \

\f0 \'a0\'a0\'a0 private float mouseScroll, scrollInput, volumeAdd, addAmount;
\f1 \

\f0 \'a0\'a0\'a0 private GameObject liquid;
\f1 \

\f0 \'a0\'a0\'a0 private Material mat;
\f1 \

\f0 \'a0\'a0\'a0 public GameObject text, plane;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 plane.SetActive(planeVis);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj = playerCamera.GetComponent<interHead>().grabbedObj;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0mouseScroll = Input.GetAxis("Mouse ScrollWheel");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 scrollInput += mouseScroll * 100;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (filling == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (volume == 0) empty = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else empty = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 volume = grabbedObj.GetComponent<volume>().curVolume;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 volumeInt = Mathf.FloorToInt(scrollInput);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (scrollInput >= 100) scrollInput = 100;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (scrollInput <= 0) scrollInput = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 volumeStr = scrollInput.ToString();
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0text.GetComponent<TextMesh>().text = "\'96\uc0\u1069 \'96\u8734 \'96\'b1\'97\u1040 \'96\u8734 \'97\u1042 \'97\u1052 : " + volumeStr + " \'96\u1033 \'96\u1111 ";
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetKeyDown(KeyCode.E))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (empty == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid = Instantiate(Resources.Load<GameObject>("Flask"));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mat = Instantiate(Resources.Load<Material>(liquidType));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.name = "Liquid";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.transform.SetParent(grabbedObj);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.transform.localScale = new Vector3(0.9f, 0.9f, 0.9f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.transform.localPosition = new Vector3(0f, 0f, 0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.transform.localRotation = Quaternion.Euler(0, 0, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid.GetComponent<MeshRenderer>().material = mat;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid = grabbedObj.Find("Liquid").gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mat = liquid.GetComponent<Renderer>().material;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 addAmount = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 addAmount = scrollInput + volume;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (addAmount >= 100) addAmount = 100;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 volumeAdd = 1f - (((addAmount) / 100f) - 0.1f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mat.SetFloat("_FillAmount", volumeAdd);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 globalVolume = scrollInput;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<volume>().addVolume();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 planeVis = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 plane.SetActive(planeVis);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 filling = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0grabbedObj = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 liquid = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Fill()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 scrollInput = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 planeVis = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 plane.SetActive(planeVis);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 filling = true;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 public class handKM : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private FixedJoint m_Joint = null;
\f1 \

\f0 \'a0\'a0\'a0 private interactable m_CurrentInteractable = null;
\f1 \

\f0 \'a0\'a0\'a0 public List<interactable> m_ContactInteractables = new List<interactable>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private Transform laser, glove, glove_A;
\f1 \

\f0 \'a0\'a0\'a0 private GameObject obj;
\f1 \

\f0 \'a0\'a0\'a0 public List<string> draggableItems;
\f1 \

\f0 \'a0\'a0\'a0 private bool laserVis, grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0 private float rotate;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void Awake()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Joint = GetComponent<FixedJoint>();
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 laser = transform.GetChild(0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove = transform.GetChild(1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A = transform.GetChild(2);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A.gameObject.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 laser.gameObject.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetMouseButtonDown(2))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 laserVis = !laserVis;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 laser.gameObject.SetActive(laserVis);
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0glove.gameObject.SetActive(!laserVis);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A.gameObject.SetActive(laserVis);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!grabbed && Input.GetMouseButtonDown(0))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 PickUp();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove.gameObject.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A.gameObject.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (grabbed)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetKeyDown(KeyCode.E))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove.gameObject.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A.gameObject.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetKeyDown(KeyCode.R))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Rigidbody targetBody = m_CurrentInteractable.GetComponent<Rigidbody>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 targetBody.AddForce(transform.forward * 800);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove.gameObject.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 glove_A.gameObject.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetMouseButton(1))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0rotate += Input.GetAxisRaw("Mouse Y") * 20;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localRotation = Quaternion.Euler(0, 0, rotate);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.parent.GetComponent<mouseView>().enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else transform.parent.GetComponent<mouseView>().enabled = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void OnTriggerEnter(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 obj = col.gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool draggable = draggableItems.Contains(obj.tag);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!draggable) return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ContactInteractables.Add(obj.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void OnTriggerExit(Collider col)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 obj = col.gameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ContactInteractables.Remove(obj.GetComponent<interactable>());
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private void PickUp()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable = GetNearestInteractable();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_CurrentInteractable) return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_CurrentInteractable.m_ActiveHand_KM)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable.m_ActiveHand_KM.Drop();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable.transform.position = transform.position;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable.transform.localRotation = Quaternion.Euler(0,0,0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Rigidbody targetBody = m_CurrentInteractable.GetComponent<Rigidbody>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Joint.connectedBody = targetBody;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable.m_ActiveHand_KM = this;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 public void Drop ()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_CurrentInteractable)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Rigidbody targetBody = m_CurrentInteractable.GetComponent<Rigidbody>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 targetBody.AddForce(targetBody.velocity * 1000);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Joint.connectedBody = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable.m_ActiveHand_KM = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CurrentInteractable = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localRotation = Quaternion.Euler(0, 0, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rotate = 0;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 private interactable GetNearestInteractable()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 interactable nearest = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float minDistance = float.MaxValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float distance = 0.0f;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach(interactable interactable in m_ContactInteractables)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (interactable == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("break");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 distance = (interactable.transform.position - transform.position).sqrMagnitude;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (distance < minDistance)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 minDistance = distance;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 nearest = interactable;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return nearest;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class interHead : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject playerCamera;
\f1 \

\f0 \'a0\'a0\'a0 public string rayTag;
\f1 \

\f0 \'a0\'a0\'a0 public int rayLenght = 30;
\f1 \

\f0 \'a0\'a0\'a0 public List<string> DraggableItems;
\f1 \

\f0 \'a0\'a0\'a0 public List<string> FillerItems;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 #region dragObj
\f1 \

\f0 \'a0\'a0\'a0 public bool grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0 public Transform grabbedObj;
\f1 \

\f0 \'a0\'a0\'a0 public float throwForce = 1000;
\f1 \

\f0 \'a0\'a0\'a0 private Vector3 grabPos, curGrabPos;
\f1 \

\f0 \'a0\'a0\'a0 private Quaternion grabRot, curGrabRot;
\f1 \

\f0 \'a0\'a0\'a0 public float objX = 1f;
\f1 \

\f0 \'a0\'a0\'a0 public float objY = -1f;
\f1 \

\f0 \'a0\'a0\'a0 public float objZ = 4f;
\f1 \

\f0 \'a0\'a0\'a0 public float smoothTime = 2;
\f1 \

\f0 \'a0\'a0\'a0 private float maxDeltaPos = 0f;
\f1 \

\f0 \'a0\'a0\'a0 private float maxDeltaRot = 0f;
\f1 \

\f0 \'a0\'a0\'a0 private float ratio, smooth;
\f1 \

\f0 \'a0\'a0\'a0 #endregion
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabPos = new Vector3(objX, objY, objZ);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 curGrabPos = new Vector3(objX, objY, objZ);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabRot = Quaternion.Euler(-90, 180, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 curGrabRot = Quaternion.Euler(-90, 180, 0);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 RaycastHit hit;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Vector3 dir = transform.TransformDirection(Vector3.forward);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Physics.Raycast(transform.position, dir, out hit, rayLenght))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rayTag = hit.collider.gameObject.tag;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool draggable = DraggableItems.Contains(rayTag);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool filler = FillerItems.Contains(rayTag);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (draggable == true && grabbed == false && Input.GetMouseButtonDown(0) == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj = hit.collider.transform;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.parent = playerCamera.transform;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().useGravity = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.localPosition = grabPos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.localRotation = grabRot;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (filler == true && grabbed == true && Input.GetMouseButtonDown(0) == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 hit.collider.GetComponent<filler>().Fill();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (grabbed == true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #region dragObj
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'96\uc0\u1028 \'96\u1032 \'96\u1033 \'96\'b5\'97\u1040 \'96\'b5\'96\u1113 \'96\u1028 \'96\'b5 \'96\u1034 \'97\u1042 \'96\u1031 \'96\u1111 \'96\u1034 \'96\u1113 \'96\'b5\'96\u1113 \'96\u1028 \'97\u1055  \'96\u1114 \'97\u1040 \'96\'b5\'96\u1110 \'96\u1033 \'96\'b5\'97\u1042 \'96\u8734  \'96\u1034 \'97\u1042  \'96\u1113 \'96\u8734 \'97\u1047 \'96\u8734 \'96\u1111 \'97\u1052 \'96\u1113 \'96\u1034 \'96\u1108  \'96\u1114 \'96\u1034 \'96\u1032 \'96\u1028 \'97\u1046 \'96\u1028 \'96\u1028 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curGrabPos = grabbedObj.localPosition;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 curGrabRot = grabbedObj.localRotation;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float deltaPos = Vector3.Distance(curGrabPos, grabPos);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float deltaRot = Vector3.Angle(curGrabPos, grabPos);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 smooth += Time.deltaTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ratio = smooth / smoothTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (smooth >= smoothTime)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 smooth = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (deltaPos >= maxDeltaPos || deltaRot >= maxDeltaRot)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.localPosition = Vector3.Lerp(curGrabPos, grabPos, ratio);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.localRotation = Quaternion.Lerp(curGrabRot, grabRot, ratio);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'97\uc0\u1043 \'96\'b1\'97\u1040 \'96\u8734 \'97\u1042 \'97\u1052  \'96\u1110 \'96\'b5\'96\u1108 \'97\u1041 \'97\u1042 \'96\u8804 \'97\u1043 \'97\u1054 \'97\u1049 \'96\u1028 \'96\'b5 \'97\u1041 \'96\u1028 \'96\u1111 \'97\u1051 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().isKinematic = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().isKinematic = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 smooth = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'96\uc0\u1034 \'97\u1042 \'96\u1114 \'97\u1043 \'97\u1041 \'97\u1042 \'96\u1028 \'97\u1042 \'97\u1052  \'96\u1114 \'97\u1040 \'96\'b5\'96\u1110 \'96\u1033 \'96\'b5\'97\u1042  
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetKeyDown(KeyCode.Q))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().useGravity = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.transform.parent = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // \'96\uc0\u1031 \'96\u1028 \'96\u1113 \'97\u1043 \'97\u1042 \'97\u1052  \'96\u1114 \'97\u1040 \'96\'b5\'96\u1110 \'96\u1033 \'96\'b5\'97\u1042 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Input.GetKeyDown(KeyCode.R))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().AddForce(dir * throwForce);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.GetComponent<Rigidbody>().useGravity = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj.transform.parent = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbedObj = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endregion
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class laserPointer : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 RaycastHit hit;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Physics.Raycast(transform.position, transform.forward, out hit))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Transform colObj = hit.collider.transform;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float distance = Vector3.Distance(colObj.position, transform.position);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Vector3 pos = new Vector3(0, 0, distance);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GetComponent<LineRenderer>().SetPosition(1, pos);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (hit.collider.tag == "Button" && Input.GetMouseButtonDown(0))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 hit.collider.GetComponent<buttonScript>().Pressed();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class lightSwitcher : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject fumeLight;
\f1 \

\f0 \'a0\'a0\'a0 public bool switched = false;
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 fumeLight.SetActive(switched);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void SwitchLight ()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 switched = !switched;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 fumeLight.SetActive(switched);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class mouseView : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0 public float mouseSensitivity = 5f;
\f1 \

\f0 \'a0\'a0 public float mouseSmoothing = 2f;
\f1 \

\f0 \'a0\'a0 public float maxAngle = 40;
\f1 \

\f0 \'a0\'a0\'a0 public float minAngle = -60;
\f1 \

\f0 \'a0\'a0 GameObject player;
\f1 \

\f0 \'a0\'a0 Vector2 mouseLook;
\f1 \

\f0 \'a0\'a0 Vector2 smooth;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 player = this.transform.parent.gameObject;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var mouseDelta = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 mouseDelta = Vector2.Scale(mouseDelta, new Vector2(mouseSensitivity * mouseSmoothing, mouseSensitivity * mouseSmoothing));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 smooth.x = Mathf.Lerp(smooth.x, mouseDelta.x, 1f / mouseSmoothing);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 smooth.y = Mathf.Lerp(smooth.y, mouseDelta.y, 1f / mouseSmoothing);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 mouseLook += smooth;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (mouseLook.y >= maxAngle)
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mouseLook.y = maxAngle;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (mouseLook.y <= minAngle)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 mouseLook.y = minAngle;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.localRotation = Quaternion.AngleAxis(-mouseLook.y, Vector3.right);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0player.transform.localRotation = Quaternion.AngleAxis(mouseLook.x, player.transform.up);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class openObject : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public Animator anim;
\f1 \

\f0 \'a0\'a0\'a0 public bool open = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 anim = GetComponent<Animator>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 anim.SetBool("open", open);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 public void Opening() \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 open = !open;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 anim.SetBool("open", open);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class playerController : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public float playerSpeed = 10f;
\f1 \

\f0 \'a0\'a0\'a0 public float vertical;
\f1 \

\f0 \'a0\'a0\'a0 public float horizontal;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Cursor.lockState = CursorLockMode.Locked;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 vertical = Input.GetAxis("Vertical") * playerSpeed * Time.deltaTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 horizontal = Input.GetAxis("Horizontal") * playerSpeed * Time.deltaTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 transform.Translate(horizontal, 0, vertical);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class tutorial : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject text1, text2, text3;
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Begin1()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 text1.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 text2.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public void Begin2()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 text2.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 text3.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class volume : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public float curVolume;
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 curVolume = 0;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 public void addVolume()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 curVolume += filler.globalVolume;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 [RequireComponent(typeof(Rigidbody))]
\f1 \

\f0 public class interactable : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [HideInInspector]
\f1 \

\f0 \'a0\'a0\'a0 public hand m_ActiveHand = null;
\f1 \

\f0 \'a0\'a0\'a0 public handKM m_ActiveHand_KM = null;
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.UI;
\f1 \

\f0 \'a0
\f1 \

\f0 public class laserPointerVR : hand
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 private GameObject rHand;
\f1 \

\f0 \'a0\'a0\'a0 public Material mat;
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 rHand = GameObject.Find("PlayerVR").transform.Find("Controller (right)").gameObject;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_GrabAction = rHand.GetComponent<hand>().m_GrabAction;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Pose = rHand.GetComponent<hand>().m_Pose;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 RaycastHit hit;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Physics.Raycast(transform.position, transform.forward, out hit))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0Transform colObj = hit.collider.transform;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float distance = Vector3.Distance(colObj.position, transform.position);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Vector3 pos = new Vector3(0, 0, distance);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GetComponent<LineRenderer>().SetPosition(1, pos);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (hit.collider.tag == "Button" && m_GrabAction.GetStateDown(m_Pose.inputSource))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string butName = hit.collider.name;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 hit.collider.GetComponent<buttonScript>().Pressed();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 public class lattices : MonoBehaviour
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public GameObject NaCl, CsCl;
\f1 \

\f0 \'a0\'a0\'a0 private GameObject obj;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 NaCl.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 CsCl.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 obj = transform.GetComponent<hand>().obj;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (obj.tag == "Lattice")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string lattice = obj.name;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (lattice == "NaCl")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 NaCl.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 NaCl.SetActive(false);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (lattice == "CsCl")
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CsCl.SetActive(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CsCl.SetActive(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 using System.Collections;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace Valve.VR
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public class SteamVR_Windows_Editor_Helper
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public enum BrowserApplication
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Unknown,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 InternetExplorer,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Firefox,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Chrome,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Opera,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Safari,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Edge,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static BrowserApplication GetDefaultBrowser()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 #if UNITY_EDITOR
\f1 \

\f0 \'a0\'a0\'a0 #if UNITY_STANDALONE_WIN
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 const string userChoice = @"Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 using (Microsoft.Win32.RegistryKey userChoiceKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(userChoice))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (userChoiceKey == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Unknown;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 object progIdValue = userChoiceKey.GetValue("Progid");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (progIdValue == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return BrowserApplication.Unknown;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string browserId = progIdValue.ToString().ToLower();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (browserId.Contains("ie.http"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.InternetExplorer;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (browserId.Contains("firefox"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Firefox;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (browserId.Contains("chrome"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Chrome;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (browserId.Contains("opera"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Opera;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (browserId.Contains("safari"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Safari;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (browserId.Contains("appcq0fevzme2pys62n3e0fbqa7peapykr8v")) //AppXq0fevzme2pys62n3e0fbqa7peapykr8v
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Edge;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Unknown;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 #else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Firefox;
\f1 \

\f0 \'a0\'a0\'a0 #endif
\f1 \

\f0 #else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return BrowserApplication.Firefox;
\f1 \

\f0 #endif
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 using UnityEngine.UI;
\f1 \

\f0 using System.Collections;
\f1 \

\f0 using TMPro;
\f1 \

\f0 \'a0
\f1 \

\f0 public class ChatController : MonoBehaviour \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public TMP_InputField TMP_ChatInput;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public TMP_Text TMP_ChatOutput;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 public Scrollbar ChatScrollbar;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void OnEnable()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TMP_ChatInput.onSubmit.AddListener(AddToChatOutput);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void OnDisable()
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 void AddToChatOutput(string newText)
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Clear Input Field
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TMP_ChatInput.text = string.Empty;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var timeNow = System.DateTime.Now;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TMP_ChatOutput.text += "[<#FFFF80>" + timeNow.Hour.ToString("d2") + ":" + timeNow.Minute.ToString("d2") + ":" + timeNow.Second.ToString("d2") + "</color>] " + newText + "\\n";
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 TMP_ChatInput.ActivateInputField();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Set the scrollbar to the bottom when next text is submitted.
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ChatScrollbar.value = 0;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 namespace TMPro.Examples
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public class TMP_TextEventCheck : MonoBehaviour
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public TMP_TextEventHandler TextEventHandler;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnEnable()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (TextEventHandler != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onWordSelection.AddListener(OnWordSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onLineSelection.AddListener(OnLineSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnDisable()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (TextEventHandler != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnCharacterSelection(char c, int index)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Character [" + c + "] at Index: " + index + " has been selected.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnSpriteSelection(char c, int index)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Sprite [" + c + "] at Index: " + index + " has been selected.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnWordSelection(string word, int firstCharacterIndex, int length)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnLineSelection(string lineText, int firstCharacterIndex, int length)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnLinkSelection(string linkID, string linkText, int linkIndex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \\"" + linkText + "\\" has been selected.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 using System.Collections;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 namespace TMPro.Examples
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 public class TMP_UiFrameRateCounter : MonoBehaviour
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public float UpdateInterval = 5.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private float m_LastInterval = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private int m_Frames = 0;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public enum FpsCounterAnchorPositions \{ TopLeft, BottomLeft, TopRight, BottomRight \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private string htmlColorTag;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private const string fpsLabel = "\{0:2\}</color> <#8080ff>FPS \\n<#FF8000>\{1:2\} <#8080ff>MS";
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private TextMeshProUGUI m_TextMeshPro;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private RectTransform m_frameCounter_transform;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 private FpsCounterAnchorPositions last_AnchorPosition;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Awake()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!enabled)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Application.targetFrameRate = -1;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GameObject frameCounter = new GameObject("Frame Counter");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform = frameCounter.AddComponent<RectTransform>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.SetParent(this.transform, false);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro = frameCounter.AddComponent<TextMeshProUGUI>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.enableWordWrapping = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.fontSize = 36;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.isOverlay = true;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Set_FrameCounter_Position(AnchorPosition);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 last_AnchorPosition = AnchorPosition;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Start()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_LastInterval = Time.realtimeSinceStartup;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Frames = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Update()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (AnchorPosition != last_AnchorPosition)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Set_FrameCounter_Position(AnchorPosition);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 last_AnchorPosition = AnchorPosition;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Frames += 1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float timeNow = Time.realtimeSinceStartup;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (timeNow > m_LastInterval + UpdateInterval)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // display two fractional digits (f2 format)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float fps = m_Frames / (timeNow - m_LastInterval);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 float ms = 1000.0f / Mathf.Max(fps, 0.00001f);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (fps < 30)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 htmlColorTag = "<color=yellow>";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (fps < 10)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 htmlColorTag = "<color=red>";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 htmlColorTag = "<color=green>";
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Frames = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_LastInterval = timeNow;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (anchor_position)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case FpsCounterAnchorPositions.TopLeft:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.pivot = new Vector2(0, 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchoredPosition = new Vector2(0, 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case FpsCounterAnchorPositions.BottomLeft:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.pivot = new Vector2(0, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchoredPosition = new Vector2(0, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case FpsCounterAnchorPositions.TopRight:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.pivot = new Vector2(1, 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchoredPosition = new Vector2(1, 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case FpsCounterAnchorPositions.BottomRight:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.pivot = new Vector2(1, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_frameCounter_transform.anchoredPosition = new Vector2(1, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 \u8232 \u8232 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class AspectRatio
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] float m_CustomAspectX = 1.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] float m_CustomAspectY = 1.0f;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] ImageAspect m_ImageAspect = ImageAspect.x16_9;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly Dictionary<ImageAspect, float> s_AspectToValue = new Dictionary<ImageAspect, float>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x16_9, 16.0f / 9.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x16_10, 16.0f / 10.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x19_10, 19.0f / 10.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x5_4, 5.0f / 4.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x4_3, 4.0f / 3.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x3_2, 3.0f / 2.0f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x1_1, 1.0f \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public float GetAspect()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_ImageAspect == ImageAspect.Custom ? m_CustomAspectX / m_CustomAspectY : s_AspectToValue[m_ImageAspect];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(AspectRatio))]
\f1 \

\f0 \'a0\'a0\'a0 class AspectRatioPropertyDrawer : PropertyDrawer
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_CustomAspectX;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_CustomAspectY;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_ImageAspect;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_Initialized;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 const string k_Format = "0.0###";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GUIContent[] s_DisplayNames;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly Dictionary<ImageAspect, string> s_AspectToName = new Dictionary<ImageAspect, string>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x19_10, "19:10 (" + AspectRatio.s_AspectToValue[ImageAspect.x19_10].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x16_9, "16:9 (" + AspectRatio.s_AspectToValue[ImageAspect.x16_9].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x16_10, "16:10 (" + AspectRatio.s_AspectToValue[ImageAspect.x16_10].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x5_4, "5:4 (" + AspectRatio.s_AspectToValue[ImageAspect.x5_4].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x4_3, "4:3 (" + AspectRatio.s_AspectToValue[ImageAspect.x4_3].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\{ ImageAspect.x3_2, "3:2 (" + AspectRatio.s_AspectToValue[ImageAspect.x3_2].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.x1_1, "1:1 (" + AspectRatio.s_AspectToValue[ImageAspect.x1_1].ToString(k_Format) + ")"\},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageAspect.Custom, "Custom"\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Initialize(SerializedProperty property)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Initialized )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Initialized = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomAspectX = property.FindPropertyRelative("m_CustomAspectX");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomAspectY = property.FindPropertyRelative("m_CustomAspectY");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ImageAspect = property.FindPropertyRelative("m_ImageAspect");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_DisplayNames == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_DisplayNames = ((ImageAspect[]) Enum.GetValues(typeof(ImageAspect))).Select(e => new GUIContent(s_AspectToName[e])).ToArray();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Initialize(property);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginProperty(position, label, property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ImageAspect.intValue = EditorGUI.Popup(position, label, m_ImageAspect.intValue, s_DisplayNames);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.EndProperty();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var aspect = (ImageAspect) m_ImageAspect.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (aspect == ImageAspect.Custom)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CustomAspectField();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void CustomAspectField()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rContent = r;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rContent.xMin = r.x + EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginChangeCheck();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int indentLevel = EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var labelWidth = EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = 0;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 const float columnWidth = 12.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0var w = Mathf.Max(30.0f, (rContent.width - columnWidth) / 3.0f);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rCurrent = rContent;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.width = w;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var x = EditorGUI.FloatField(rCurrent, m_CustomAspectX.floatValue);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.x += w;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.width = columnWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.LabelField(rCurrent, ":");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.x += columnWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.width = w;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var y\'a0 = EditorGUI.FloatField(rCurrent, m_CustomAspectY.floatValue );
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EditorGUI.EndChangeCheck())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomAspectX.floatValue = Mathf.Max(x, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomAspectY.floatValue = Mathf.Max(y, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var aspect = m_CustomAspectX.floatValue / m_CustomAspectY.floatValue;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.xMin = rCurrent.xMax + 3.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rCurrent.xMax = r.xMax;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.LabelField(rCurrent, "(" + aspect.ToString(k_Format) + ")");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0EditorGUI.indentLevel = indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{ 
\f1 \

\f0 \'a0\'a0\'a0 abstract class BaseRenderTextureInput : RecorderInput
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RenderTexture outputRT \{ get; set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int outputWidth \{ get; protected set; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int outputHeight \{ get; protected set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected void ReleaseBuffer()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (outputRT != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (outputRT == RenderTexture.active)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RenderTexture.active = null;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputRT.Release();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputRT = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected override void Dispose(bool disposing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.Dispose(disposing);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (disposing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ReleaseBuffer();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Experimental.UIElements;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class EditableLabel : VisualElement
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly Label m_Label;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly TextField m_TextField;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_IsEditing;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Action<string> m_OnValueChangedCallback;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Focusable m_PreviouslyFocused;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string text
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Label.text; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Label.text = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void SetLabelEnabled(bool value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0m_Label.SetEnabled(value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal EditableLabel()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IsEditing = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Label = new Label();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextField = new TextField();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetFlex(this, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetFlex(m_TextField, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_Label);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RegisterCallback<KeyUpEvent>(OnKeyUpCallback, Capture.Capture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextField.RegisterCallback<FocusOutEvent>(OnTextFieldLostFocus);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void SetValueAndNotify(string newValue)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EqualityComparer<string>.Default.Equals(m_Label.text, newValue))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(newValue))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Label.text = newValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_OnValueChangedCallback != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnValueChangedCallback.Invoke(newValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void OnValueChanged(Action<string> callback)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnValueChangedCallback = callback;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void StartEditing()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_IsEditing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IsEditing = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextField.value = m_Label.text;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Remove(m_Label);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_TextField);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextField.focusIndex = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_PreviouslyFocused = focusController.focusedElement;\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_TextField.Focus();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void ApplyEditing()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_IsEditing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SetValueAndNotify(m_TextField.text);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IsEditing = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Remove(m_TextField);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_Label);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void CancelEditing()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_IsEditing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IsEditing = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Remove(m_TextField);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_Label);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnTextFieldLostFocus(FocusOutEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ApplyEditing();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnKeyUpCallback(KeyUpEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_IsEditing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.keyCode == KeyCode.Return || evt.keyCode == KeyCode.KeypadEnter)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ApplyEditing();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RestorePreviousFocus();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (evt.keyCode == KeyCode.Escape)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 CancelEditing();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RestorePreviousFocus();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void RestorePreviousFocus()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_PreviouslyFocused != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_PreviouslyFocused.Focus();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 abstract class EnumProperyDrawer<T> : PropertyDrawer
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0GUIContent[] m_DisplayNames;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_DisplayNames == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var displayNames = new List<GUIContent>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (T frameRate in Enum.GetValues(typeof(T)))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 displayNames.Add(new GUIContent(ToLabel(frameRate)));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_DisplayNames = displayNames.ToArray();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginProperty(position, label, property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 property.intValue = EditorGUI.Popup(position, label, property.intValue, m_DisplayNames);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.EndProperty();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected abstract string ToLabel(T value); 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Globalization;
\f1 \

\f0 using System.IO;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using System.Text.RegularExpressions;
\f1 \

\f0 using UnityEditor.Recorder.Input;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class Wildcard
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly string m_Pattern;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly string m_Label;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly Func<RecordingSession, string> m_Resolver;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string pattern \{ get \{ return m_Pattern; \} \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string label \{ get \{ return m_Label; \} \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal Wildcard(string pattern, Func<RecordingSession, string> resolver, string info = null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Pattern = pattern;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Label = m_Pattern;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (info != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Label += " " + info;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Resolver = resolver;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string Resolve(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_Resolver == null ? string.Empty : m_Resolver(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 /// <summary>
\f1 \

\f0 \'a0\'a0\'a0 /// Helper class for default wildcards that can be used when constructing the output file of a recorder.
\f1 \

\f0 \'a0\'a0\'a0 /// <see cref="RecorderSettings.outputFile"/>
\f1 \

\f0 \'a0\'a0\'a0 /// </summary>
\f1 \

\f0 \'a0\'a0\'a0 public static class DefaultWildcard
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Recorder = GeneratePattern("Recorder");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Time = GeneratePattern("Time");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Take = GeneratePattern("Take");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Date = GeneratePattern("Date");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Project = GeneratePattern("Project");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Product = GeneratePattern("Product");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Scene = GeneratePattern("Scene");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Resolution = GeneratePattern("Resolution");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Frame = GeneratePattern("Frame");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static readonly string Extension = GeneratePattern("Extension");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static string GeneratePattern(string tag)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "<" + tag + ">";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class FileNameGenerator
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string s_ProjectName;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] OutputPath m_Path = new OutputPath();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] string m_FileName = DefaultWildcard.Recorder;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly List<Wildcard> m_Wildcards;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public IEnumerable<Wildcard> wildcards
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Wildcards; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void FromPath(string str)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 str = SanitizePath(str);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var i = str.LastIndexOf('/');
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (i != -1 && i < str.Length - 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName = str.Substring(i + 1);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (i == 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path.root = OutputPath.Root.Absolute;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path.leaf = "/";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 str = str.Substring(0, i);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path = OutputPath.FromPath(str);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName = str;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path.root = OutputPath.Root.Absolute;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path.leaf = string.Empty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string ToPath()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var path = m_Path.GetFullPath();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!string.IsNullOrEmpty(path))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 path += "/";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return SanitizePath(path + SanitizeFilename(m_FileName));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string fileName \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_FileName; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_FileName = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal OutputPath.Root root
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Path.root; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Path.root = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string leaf
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Path.leaf; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Path.leaf = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool forceAssetsFolder
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Path.forceAssetsFolder; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Path.forceAssetsFolder = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly RecorderSettings m_RecorderSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal FileNameGenerator(RecorderSettings recorderSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderSettings = recorderSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Wildcards = new List<Wildcard>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Recorder, RecorderResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Time, TimeResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Take, TakeResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Date, DateResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Project, ProjectNameResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Product, ProductNameResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Scene, SceneResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Resolution, ResolutionResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Frame, FrameResolver),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 new Wildcard(DefaultWildcard.Extension, ExtensionResolver)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void AddWildcard(string tag, Func<RecordingSession, string> resolver)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Wildcards.Add(new Wildcard(tag, resolver));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string RecorderResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_RecorderSettings.name;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string TimeResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var date = session != null ? session.sessionStartTS : DateTime.Now;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return string.Format("\{0:HH\}h\{1:mm\}m", date, date);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string TakeResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_RecorderSettings.take.ToString("000");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string DateResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var date = session != null ? session.sessionStartTS : DateTime.Now;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return date.ToString(CultureInfo.InvariantCulture).Replace('/', '-');
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string ExtensionResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_RecorderSettings.extension;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string ResolutionResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var input = m_RecorderSettings.inputsSettings.FirstOrDefault() as ImageInputSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (input == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "NA";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return input.outputWidth + "x" + input.outputHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string SceneResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return SceneManager.GetActiveScene().name;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string FrameResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var i = session != null ? session.frameIndex : 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return i.ToString("0000");
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string ProjectNameResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(s_ProjectName))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var parts = Application.dataPath.Split('/');
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_ProjectName = parts[parts.Length - 2];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_ProjectName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string ProductNameResolver(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return PlayerSettings.productName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal string BuildAbsolutePath(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var fullPath = ApplyWildcards(ToPath(), session) + "." + ExtensionResolver(session);\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 string drive = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Application.platform == RuntimePlatform.WindowsEditor)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (fullPath.Length > 2 && char.IsLetter(fullPath[0]) && fullPath[1] == ':' && fullPath[2] == '/')
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 drive = fullPath.Substring(0, 2);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fullPath = fullPath.Substring(3);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fullPath = string.Join(Path.DirectorySeparatorChar.ToString(), fullPath.Split('/').Select(s =>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Path.GetInvalidFileNameChars().Aggregate(s, (current, c) => current.Replace(c.ToString(), string.Empty))).ToArray());
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!string.IsNullOrEmpty(drive))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fullPath = drive.ToUpper() + Path.DirectorySeparatorChar + fullPath;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return fullPath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void CreateDirectory(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var path = ApplyWildcards(m_Path.GetFullPath(), session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(!string.IsNullOrEmpty(path) && !Directory.Exists(path))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Directory.CreateDirectory(path);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static string SanitizeFilename(string filename)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 filename = filename.Replace("\\\\", "");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 filename = Regex.Replace(filename, "/", "");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return filename;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static string SanitizePath(string fullPath)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fullPath = fullPath.Replace("\\\\", "/");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fullPath = Regex.Replace(fullPath, "/+", "/");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return fullPath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string ApplyWildcards(string str, RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(str))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return string.Empty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var w in wildcards)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 str = str.Replace(w.pattern, w.Resolve(session));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return str;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.IO;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(FileNameGenerator))]
\f1 \

\f0 \'a0\'a0\'a0 class FileNameGeneratorDrawer : TargetedPropertyDrawer<FileNameGenerator>
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_FileName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_Path;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static bool s_Dirty = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly GUIStyle s_PathPreviewStyle = new GUIStyle(GUI.skin.label) \{ wordWrap = true \};
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 static readonly GUIStyle s_OpenPathButtonStyle = new GUIStyle("minibutton") \{ fixedWidth = 30 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0 static Texture2D s_OpenPathIcon;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected override void Initialize(SerializedProperty property)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_OpenPathIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var iconName = "popout_icon";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EditorGUIUtility.isProSkin)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 iconName = "d_" + iconName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_OpenPathIcon = Resources.Load<Texture2D>(iconName);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName = property.FindPropertyRelative("m_FileName");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Path = property.FindPropertyRelative("m_Path");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginProperty(position, label, property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 const float tagWidth = 77;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var txtWidth = position.width - tagWidth - 5;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var txtRect = new Rect(position.x, position.y, txtWidth, position.height);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var tagRect = new Rect(position.x + txtWidth + 5, position.y, tagWidth, position.height);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.SetNextControlName("FileNameField");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName.stringValue = GUI.TextField(txtRect, m_FileName.stringValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var editor = (TextEditor)GUIUtility.GetStateObject(typeof(TextEditor), GUIUtility.keyboardControl);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (GUI.GetNameOfFocusedControl().Equals("FileNameField") && 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0Event.current.type == EventType.KeyUp && (Event.current.modifiers == EventModifiers.Control || Event.current.modifiers == EventModifiers.Command))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Event.current.keyCode == KeyCode.C)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0Event.current.Use();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 editor.Copy();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (Event.current.keyCode == KeyCode.V)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Event.current.Use();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 editor.Paste();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0m_FileName.stringValue = editor.text;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EditorGUI.DropdownButton(tagRect, new GUIContent("+ Wildcards"), FocusType.Passive))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var menu = new GenericMenu();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0foreach (var w in target.wildcards)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var pattern = w.pattern;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 menu.AddItem(new GUIContent(w.label), false, () =>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName.stringValue = InsertTag(pattern, m_FileName.stringValue, editor);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileName.serializedObject.ApplyModifiedProperties();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Dirty = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \});
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 menu.DropDown(tagRect);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_Dirty)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Dirty = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.changed = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_Path);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.BeginHorizontal();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PrefixLabel(" ");
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var path = target.BuildAbsolutePath(null);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = GUILayoutUtility.GetRect(new GUIContent(path), s_PathPreviewStyle, null);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.SelectableLabel(r, path, s_PathPreviewStyle);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (GUILayout.Button(s_OpenPathIcon, s_OpenPathButtonStyle))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OpenInFileBrowser.Open(path);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.EndHorizontal();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.EndProperty();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string InsertTag(string pattern, string text, TextEditor editor)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!string.IsNullOrEmpty(editor.text)) // HACK If editor is not focused on
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 editor.ReplaceSelection(pattern);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return editor.text;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // ignored
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0return text + pattern;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0 
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 abstract class GenericRecorder<T> : Recorder where T : RecorderSettings
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField]
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected T m_Settings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override RecorderSettings settings
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Settings; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Settings = (T)value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class ImageHeightSelector
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string[] m_ToName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int[] m_ToEnumValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly Dictionary<ImageHeight, int> m_ToIndex = new Dictionary<ImageHeight, int>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int m_Max;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly bool m_AllowCustom;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly bool m_AllowWindow;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly Dictionary<ImageHeight, string> s_HeightToName = new Dictionary<ImageHeight, string>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x4320p_8K, "8K - 4320p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x2880p_5K, "5K - 2880p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x2160p_4K, "4K - 2160p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x1440p_QHD, "QHD - 1440p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x1080p_FHD, "FHD - 1080p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x720p_HD, "HD - 720p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x480p, "SD - 480p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.x240p, "240p" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.Window, "Match Window Size" \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ ImageHeight.Custom, "Custom" \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0public ImageHeightSelector(int max, bool allowCustom = true, bool allowWindow = true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_AllowCustom = allowCustom;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_AllowWindow = allowWindow;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 BuildPopup(max);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void BuildPopup(int max)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var values = (ImageHeight[]) Enum.GetValues(typeof(ImageHeight));
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ordered = new List<ImageHeight>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_AllowWindow)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ordered.Add(ImageHeight.Window);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ordered.AddRange(values.Where(value => value != ImageHeight.Window && value != ImageHeight.Custom && (int)value <= max));
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_AllowCustom)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ordered.Add(ImageHeight.Custom);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var count = ordered.Count;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ToName = new string[count];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ToEnumValue = new int[count];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for (int i = 0; i < count; ++i)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var e = ordered[i];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ToName[i] = s_HeightToName[e];
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0m_ToEnumValue[i] = (int)e;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ToIndex[e] = i;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Max = max;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int Popup(GUIContent label, int value, int max)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Max != max)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 BuildPopup(max);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int index;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_ToIndex.TryGetValue((ImageHeight) value, out index))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 index = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 index = EditorGUILayout.Popup(label, index, m_ToName);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_ToEnumValue[index];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using UnityEditor.Recorder.Input;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class ImageInputSelector : InputSettingsSelector
\f1 \

\f0 \'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public GameViewInputSettings gameViewInputSettings = new GameViewInputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public CameraInputSettings cameraInputSettings = new CameraInputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public Camera360InputSettings camera360InputSettings = new Camera360InputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public RenderTextureInputSettings renderTextureInputSettings = new RenderTextureInputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public RenderTextureSamplerSettings renderTextureSamplerSettings = new RenderTextureSamplerSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public ImageInputSettings imageInputSettings
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return (ImageInputSettings)selected; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentNullException("value");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value is CameraInputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is GameViewInputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is Camera360InputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is RenderTextureInputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is RenderTextureSamplerSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selected = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentException("Video input type not supported: '" + value.GetType() + "'");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void ForceEvenResolution(bool value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 gameViewInputSettings.forceEvenSize = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 cameraInputSettings.forceEvenSize = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class UTJImageInputSelector : InputSettingsSelector
\f1 \

\f0 \'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public CameraInputSettings cameraInputSettings = new CameraInputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public RenderTextureInputSettings renderTextureInputSettings = new RenderTextureInputSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] public RenderTextureSamplerSettings renderTextureSamplerSettings = new RenderTextureSamplerSettings();
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public ImageInputSettings imageInputSettings
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return (ImageInputSettings)selected; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentNullException("value");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value is CameraInputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is RenderTextureInputSettings ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 value is RenderTextureSamplerSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selected = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentException("Video input type not supported: '" + value.GetType() + "'");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using System.Reflection;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 abstract class InputSettingsSelector
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] string m_Selected;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly Dictionary<string, RecorderInputSettings> m_RecorderInputSettings = new Dictionary<string, RecorderInputSettings>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderInputSettings selected
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(m_Selected) || !m_RecorderInputSettings.ContainsKey(m_Selected))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Selected = m_RecorderInputSettings.Keys.First();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_RecorderInputSettings[m_Selected];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected set
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var field in InputSettingFields())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var input = (RecorderInputSettings)field.GetValue(this);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (input.GetType() == value.GetType())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 field.SetValue(this, value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Selected = field.Name;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderInputSettings[m_Selected] = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public IEnumerable<FieldInfo> InputSettingFields()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return GetInputFields(GetType()).Where(f => typeof(RecorderInputSettings).IsAssignableFrom(f.FieldType));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static IEnumerable<FieldInfo> GetInputFields(Type type)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected InputSettingsSelector()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var field in InputSettingFields())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var input = (RecorderInputSettings)field.GetValue(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderInputSettings.Add(field.Name, input);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.ComponentModel;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(InputSettingsSelector), true)]
\f1 \

\f0 \'a0\'a0\'a0 class InputSettingsSelectorDrawer : TargetedPropertyDrawer<InputSettingsSelector>
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_Initialized;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUIContent[] m_DisplayNames;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Dictionary<string, int> m_NameToIndex;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Dictionary<int, SerializedProperty> m_IndexToProperty;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_Initialized)
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Initialized = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_DisplayNames.Length == 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.LabelField("No input to select.");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var newIndex = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var selected = property.FindPropertyRelative("m_Selected");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_DisplayNames.Length > 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int index;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_NameToIndex.TryGetValue(selected.stringValue, out index);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 newIndex = EditorGUILayout.Popup(label, index, m_DisplayNames);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sp = m_IndexToProperty[newIndex];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selected.stringValue = sp.name;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(sp, true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 --EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected override void Initialize(SerializedProperty property)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_NameToIndex = new Dictionary<string, int>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IndexToProperty = new Dictionary<int, SerializedProperty>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var displayNames = new List<GUIContent>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0int i = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var field in target.InputSettingFields())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sp = property.FindPropertyRelative(field.Name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_NameToIndex.Add(sp.name, i);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_IndexToProperty.Add(i, sp);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 displayNames.Add(new GUIContent(GetTypeDisplayName(field.FieldType)));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++i;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_DisplayNames = displayNames.ToArray();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string GetTypeDisplayName(Type type)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var displayNameAttribute = type.GetCustomAttributes(typeof(DisplayNameAttribute), true).FirstOrDefault() as DisplayNameAttribute;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return displayNameAttribute != null
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ? displayNameAttribute.DisplayName
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 : ObjectNames.NicifyVariableName(type.Name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 enum FrameRateType
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_23, // 24 * 1000 / 1001
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_24,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_25,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_29, // 30 * 1000 / 1001,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_30,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_50,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_59, // 60 * 1000 / 1001,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_60,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FR_CUSTOM,
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 enum ImageAspect
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x19_10,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x16_9,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x16_10,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x3_2,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x4_3,
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0x5_4,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x1_1,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Custom
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 enum ImageHeight
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Window = 0,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x4320p_8K = 4320,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x2880p_5K = 2880,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x2160p_4K = 2160,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x1440p_QHD = 1440,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x1080p_FHD = 1080,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x720p_HD = 720,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x480p = 480,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 x240p = 240,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Custom = int.MaxValue
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Text.RegularExpressions;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class OutputPath
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public enum Root
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Project,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AssetsFolder,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 StreamingAssets,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 PersistentData,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 TemporaryCache,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Absolute
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] Root m_Root;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] string m_Leaf;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] bool m_ForceAssetFolder;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public Root root
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Root; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Root = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string leaf
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Leaf; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_Leaf = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public bool forceAssetsFolder
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_ForceAssetFolder;\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ForceAssetFolder = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_ForceAssetFolder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Root = Root.AssetsFolder;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static OutputPath FromPath(string path)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var result = new OutputPath();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (path.Contains(Application.streamingAssetsPath))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.StreamingAssets;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path.Replace(Application.streamingAssetsPath, string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (path.Contains(Application.dataPath))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.AssetsFolder;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path.Replace(Application.dataPath, string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0else if (path.Contains(Application.persistentDataPath))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.PersistentData;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path.Replace(Application.persistentDataPath, string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (path.Contains(Application.temporaryCachePath))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.TemporaryCache;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path.Replace(Application.temporaryCachePath, string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (path.Contains(ProjectPath()))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.Project;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path.Replace(ProjectPath(), string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Root = Root.Absolute;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.m_Leaf = path;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return result;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static string GetFullPath(Root root, string leaf)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ret = string.Empty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (root)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case Root.PersistentData:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret = Application.persistentDataPath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case Root.StreamingAssets:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret = Application.streamingAssetsPath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case Root.TemporaryCache:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret = Application.temporaryCachePath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case Root.AssetsFolder:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret = Application.dataPath;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case Root.Project:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret = ProjectPath();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (root != Root.Absolute && !leaf.StartsWith("/"))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ret += "/";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0ret += leaf;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return ret;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string GetFullPath()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return GetFullPath(m_Root, m_Leaf);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static string ProjectPath()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return Regex.Replace(Application.dataPath, "/Assets$", string.Empty);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.IO;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(OutputPath))]
\f1 \

\f0 \'a0\'a0\'a0 class OutputPathDrawer : TargetedPropertyDrawer<OutputPath>
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_RootProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_LeafProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_ForceAssetFolder;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected override void Initialize(SerializedProperty property)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_RootProperty == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RootProperty = property.FindPropertyRelative("m_Root");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_LeafProperty == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_LeafProperty = property.FindPropertyRelative("m_Leaf");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_ForceAssetFolder == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ForceAssetFolder = property.FindPropertyRelative("m_ForceAssetFolder");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginProperty(position, label, property);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var indent = EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = 0;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 const float rootWidth = 110.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 const float btnWidth = 30.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var leafWidth = target.forceAssetsFolder ? position.width - rootWidth : position.width - rootWidth - btnWidth - 10;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rootRect = new Rect(position.x, position.y, rootWidth, position.height);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var leafRect = new Rect(position.x + rootWidth + 5, position.y, leafWidth, position.height);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var btnRect = new Rect(position.x + rootWidth\'a0 + leafWidth + 10, position.y, btnWidth, position.height);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target.forceAssetsFolder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var root = (OutputPath.Root) m_RootProperty.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.Label(rootRect, root + " " + Path.DirectorySeparatorChar);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.PropertyField(rootRect, m_RootProperty, GUIContent.none);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.PropertyField(leafRect, m_LeafProperty, GUIContent.none);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var fullPath = OutputPath.GetFullPath((OutputPath.Root)m_RootProperty.intValue, m_LeafProperty.stringValue);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!target.forceAssetsFolder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0if (GUI.Button(btnRect, new GUIContent("...", fullPath)))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var newPath = EditorUtility.OpenFolderPanel("Select output location", fullPath, "");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!string.IsNullOrEmpty(newPath))
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var newValue = OutputPath.FromPath(newPath);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RootProperty.intValue = (int) newValue.root;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_LeafProperty.stringValue = newValue.leaf;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = indent;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.EndProperty();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using UnityEditor.Recorder.Input;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0 class OutputResolution
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] int m_CustomWidth = 1024;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] int m_CustomHeight = 1024;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] internal ImageHeight imageHeight = ImageHeight.x720p_HD;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] internal ImageHeight maxSupportedHeight = ImageHeight.x4320p_8K;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] AspectRatio m_AspectRatio = new AspectRatio();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int GetWidth()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (imageHeight == ImageHeight.Custom)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_CustomWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (imageHeight == ImageHeight.Window)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int w, h;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GameViewSize.GetGameRenderSize(out w, out h);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return w;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var aspect = m_AspectRatio.GetAspect();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return (int) (aspect * (int)imageHeight);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int GetHeight()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (imageHeight == ImageHeight.Custom)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_CustomHeight;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (imageHeight == ImageHeight.Window)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 int w, h;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GameViewSize.GetGameRenderSize(out w, out h);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return h;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return (int)imageHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetWidth(int w)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 imageHeight = ImageHeight.Custom;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomWidth = w;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetHeight(int h)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 imageHeight = ImageHeight.Custom;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomHeight = h;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(OutputResolution))]
\f1 \

\f0 \'a0\'a0\'a0 class OutputResolutionPropertyDrawer : PropertyDrawer
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0SerializedProperty m_CustomWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_CustomHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_ImageHeight;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_AspectRatio;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_MaxSupportedHeight;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ImageHeightSelector m_HeightSelector;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_Initialized;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static class Styles
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent ImageAspectLabel = new GUIContent("Aspect Ratio");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly GUIContent s_CustomWidthLabel = new GUIContent("W");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly GUIContent s_CustomHeightLabel = new GUIContent("H");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent[] CustomDimensionsLabels = \{ s_CustomWidthLabel, s_CustomHeightLabel \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void Initialize(SerializedProperty property)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Initialized )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Initialized = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomWidth = property.FindPropertyRelative("m_CustomWidth");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomHeight = property.FindPropertyRelative("m_CustomHeight");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0m_ImageHeight = property.FindPropertyRelative("imageHeight");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_AspectRatio = property.FindPropertyRelative("m_AspectRatio");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_MaxSupportedHeight = property.FindPropertyRelative("maxSupportedHeight");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_HeightSelector = new ImageHeightSelector(m_MaxSupportedHeight.intValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Initialize(property);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ImageHeight.intValue = m_HeightSelector.Popup(label, m_ImageHeight.intValue, m_MaxSupportedHeight.intValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var selected = (ImageHeight) m_ImageHeight.intValue;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selected == ImageHeight.Custom)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var outputDimensions = new int[2];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions[0] = m_CustomWidth.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions[1] = m_CustomHeight.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (UIElementHelper.MultiIntField(GUIContent.none, Styles.CustomDimensionsLabels, outputDimensions))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomWidth.intValue = outputDimensions[0];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomHeight.intValue = outputDimensions[1];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selected != ImageHeight.Custom && selected != ImageHeight.Window)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_AspectRatio, Styles.ImageAspectLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using UnityEditor.Experimental.UIElements;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Experimental.UIElements;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class PanelSplitter : VisualElement
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly VisualElement m_AffectedElement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0bool m_Grabbed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Vector2 m_GrabbedMousePosition;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float m_ElementOriginalWidth;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 const float k_SplitterWidth = 5.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 class Width
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public float value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Width m_Width;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void SetWidth(float value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Width == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Width.value = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_AffectedElement.style.width = value;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0SavePersistentData();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public PanelSplitter(VisualElement affectedElement)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_AffectedElement = affectedElement;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style.cursor = UIElementsEditorUtility.CreateDefaultCursorStyle(MouseCursor.ResizeHorizontal);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style.width = k_SplitterWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style.minWidth = k_SplitterWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style.maxWidth = k_SplitterWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RegisterCallback<MouseDownEvent>(OnMouseDown, Capture.Capture);
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0RegisterCallback<MouseMoveEvent>(OnMouseMove, Capture.Capture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RegisterCallback<MouseUpEvent>(OnMouseUp, Capture.Capture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnMouseDown(MouseDownEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.button != (int) MouseButton.LeftMouse)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Grabbed)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.TakeMouseCapture();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Grabbed = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_GrabbedMousePosition = evt.mousePosition;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ElementOriginalWidth = m_AffectedElement.style.width;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnMouseMove(MouseMoveEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_Grabbed)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0var delta = evt.mousePosition.x - m_GrabbedMousePosition.x;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var newWidth = Mathf.Max(m_ElementOriginalWidth + delta, m_AffectedElement.style.minWidth);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_AffectedElement.style.maxWidth > 0.0f)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0newWidth = Mathf.Min(newWidth, m_AffectedElement.style.maxWidth);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SetWidth(newWidth);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnMouseUp(MouseUpEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.button != (int) MouseButton.LeftMouse)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_Grabbed)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Grabbed = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.ReleaseMouseCapture();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnPersistentDataReady()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.OnPersistentDataReady();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var key = GetFullHierarchicalPersistenceKey();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Width = GetOrCreatePersistentData<Width>(m_Width, key);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Width.value > 0.0f)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0m_AffectedElement.style.width = m_Width.value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 enum ERecordingSessionStage
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 BeginRecording,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 NewFrameStarting,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 NewFrameReady,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 FrameDone,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 EndRecording,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SessionCreated
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 abstract class Recorder : ScriptableObject
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static int sm_CaptureFrameRateCount;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_ModifiedCaptureFR;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int recordedFramesCount \{ get; set; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected List<RecorderInput> m_Inputs;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void Awake()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sm_CaptureFrameRateCount = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void Reset()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recordedFramesCount = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recording = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void OnDestroy()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_ModifiedCaptureFR )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sm_CaptureFrameRateCount--;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0if (sm_CaptureFrameRateCount == 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Time.captureFramerate = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Recorder resetting 'CaptureFrameRate' to zero");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public abstract RecorderSettings settings \{ get; set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void SessionCreated(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(string.Format("Recorder \{0\} session created", GetType().Name));
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings.SelfAdjustSettings(); // ignore return value.
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var fixedRate = settings.frameRatePlayback == FrameRatePlayback.Constant ? (int)settings.frameRate : 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (fixedRate > 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Time.captureFramerate != 0 && fixedRate != Time.captureFramerate )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogError(string.Format("Recorder \{0\} is set to record at a fixed rate and another component has already set a conflicting value for [Time.captureFramerate], new value being applied : \{1\}!", GetType().Name, fixedRate));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if( Time.captureFramerate == 0 && Options.verboseMode )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Frame recorder set fixed frame rate to " + fixedRate);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Time.captureFramerate = fixedRate;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sm_CaptureFrameRateCount++;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ModifiedCaptureFR = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Inputs = new List<RecorderInput>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var inputSettings in settings.inputsSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var input = (RecorderInput)Activator.CreateInstance(inputSettings.inputType);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.settings = inputSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Inputs.Add(input);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SignalInputsOfStage(ERecordingSessionStage.SessionCreated, session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual bool BeginRecording(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (recording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new Exception("Already recording!");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(string.Format("Recorder \{0\} starting to record", GetType().Name));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return recording = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void EndRecording(RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!recording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recording = false;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_ModifiedCaptureFR )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ModifiedCaptureFR = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0sm_CaptureFrameRateCount--;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (sm_CaptureFrameRateCount == 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Time.captureFramerate = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Recorder resetting 'CaptureFrameRate' to zero");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var input in m_Inputs)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (input != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.Dispose();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(string.Format("\{0\} recording stopped, total frame count: \{1\}", GetType().Name, recordedFramesCount));
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++settings.take;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public abstract void RecordFrame(RecordingSession ctx);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void PrepareNewFrame(RecordingSession ctx)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual bool SkipFrame(RecordingSession ctx)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return !recording 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 || (ctx.frameIndex % settings.captureEveryNthFrame) != 0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 || ( settings.recordMode == RecordMode.TimeInterval && ctx.currentFrameStartTS < settings.startTime )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 || ( settings.recordMode == RecordMode.FrameInterval && ctx.frameIndex < settings.startFrame )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0|| ( settings.recordMode == RecordMode.SingleFrame && ctx.frameIndex < settings.startFrame );
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public bool recording \{ get; protected set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SignalInputsOfStage(ERecordingSessionStage stage, RecordingSession session)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Inputs == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (stage)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.SessionCreated:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0input.SessionCreated(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.BeginRecording:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.BeginRecording(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.NewFrameStarting:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.NewFrameStarting(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.NewFrameReady:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.NewFrameReady(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.FrameDone:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.FrameDone(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case ERecordingSessionStage.EndRecording:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach( var input in m_Inputs )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 input.EndRecording(session);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 default:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentOutOfRangeException("stage", stage, null);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.IO;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEditorInternal;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityObject = UnityEngine.Object;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 public class RecorderControllerSettings : ScriptableObject
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] RecordMode m_RecordMode = RecordMode.Manual;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] FrameRatePlayback m_FrameRatePlayback = FrameRatePlayback.Constant;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] FrameRateType m_FrameRateType = FrameRateType.FR_30;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] [Range(1.0f, 120.0f)] float m_CustomFrameRateValue = 30.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] int m_StartFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] int m_EndFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] float m_StartTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] float m_EndTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] bool m_CapFrameRate = true;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly Dictionary<FrameRateType, float> s_FPSToValue = new Dictionary<FrameRateType, float>()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_23, 24 * 1000 / 1001f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_24, 24 \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_25, 25 \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_29, 30 * 1000 / 1001f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_30, 30 \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_50, 50 \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_59, 60 * 1000 / 1001f \},
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{ FrameRateType.FR_60, 60 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public FrameRatePlayback frameRatePlayback
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_FrameRatePlayback; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_FrameRatePlayback = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public float frameRate
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_FrameRateType == FrameRateType.FR_CUSTOM ? m_CustomFrameRateValue : s_FPSToValue[m_FrameRateType];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FrameRateType = FrameRateType.FR_CUSTOM;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CustomFrameRateValue = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetRecordModeToManual()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordMode = RecordMode.Manual;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetRecordModeToSingleFrame(int frameNumber)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordMode = RecordMode.SingleFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartFrame = m_EndFrame = frameNumber;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetRecordModeToFrameInterval(int startFrame, int endFrame)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordMode = RecordMode.FrameInterval;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartFrame = startFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndFrame = endFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetRecordModeToTimeInterval(float startTime, float endTime)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0m_RecordMode = RecordMode.TimeInterval;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartTime = startTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndTime = endTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public bool capFrameRate
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_CapFrameRate; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set \{ m_CapFrameRate = value; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [SerializeField] List<RecorderSettings> m_RecorderSettings = new List<RecorderSettings>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 string m_Path;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static RecorderControllerSettings LoadOrCreate(string path)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0RecorderControllerSettings prefs;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var objs = InternalEditorUtility.LoadSerializedFileAndForget(path);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs = objs.FirstOrDefault(p => p is RecorderControllerSettings) as RecorderControllerSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception e)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogError("Unhandled exception while loading Recorder preferences: " + e);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (prefs == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs = CreateInstance<RecorderControllerSettings>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.hideFlags = HideFlags.DontSave | HideFlags.HideInHierarchy;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.name = "Global Settings";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.Save();
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.m_Path = path;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return prefs;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void ReleaseRecorderSettings()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var recorder in m_RecorderSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0DestroyImmediate(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ClearRecorderSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void ClearRecorderSettings()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderSettings.Clear();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public IEnumerable<RecorderSettings> recorderSettings
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_RecorderSettings; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void AddRecorderSettings(RecorderSettings recorder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_RecorderSettings.Contains(recorder))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AddRecorderInternal(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Save();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void RemoveRecorder(RecorderSettings recorder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_RecorderSettings.Contains(recorder))
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderSettings.Remove(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Save();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Save()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(m_Path))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var directory = Path.GetDirectoryName(m_Path);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Directory.CreateDirectory(directory);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recordersCopy = recorderSettings.ToArray();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var objs = new UnityObject[recordersCopy.Length + 1];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 objs[0] = this;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for (int i = 0; i < recordersCopy.Length; ++i)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 objs[i + 1] = recordersCopy[i];
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 InternalEditorUtility.SaveToSerializedFileAndForget(objs, m_Path, true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception e)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogError("Unhandled exception while saving Recorder settings: " + e);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void ApplyGlobalSetting(RecorderSettings recorder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.recordMode = m_RecordMode;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.frameRatePlayback = m_FrameRatePlayback;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.frameRate = frameRate;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.startFrame = m_StartFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.endFrame = m_EndFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.startTime = m_StartTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.endTime = m_EndTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.capFrameRate = m_CapFrameRate;
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0recorder.hideFlags = HideFlags.DontSave | HideFlags.HideInHierarchy;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SelfAdjustSettings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void ApplyGlobalSettingToAllRecorders()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var recorder in recorderSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ApplyGlobalSetting(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void AddRecorderInternal(RecorderSettings recorder)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ApplyGlobalSetting(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderSettings.Add(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{\'a0 
\f1 \

\f0 \'a0\'a0\'a0 [CustomEditor(typeof(RecorderControllerSettingsPreset))]
\f1 \

\f0 \'a0\'a0\'a0 class RecorderControllerSettingsPresetEditor : Editor
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Editor m_Editor;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0class PresetEditorState
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public bool expanded;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public Editor presetEditor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly List<PresetEditorState> m_RecordersEditors = new List<PresetEditorState>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnEnable()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var preset = (RecorderControllerSettingsPreset) target;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Editor = CreateEditor(preset.model);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordersEditors.Clear();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recorderPresets = preset.recorderPresets;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var p in recorderPresets)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var state = new PresetEditorState
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 presetEditor = CreateEditor(p),
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0expanded = false
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordersEditors.Add(state);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnInspectorGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Editor.OnInspectorGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var state in m_RecordersEditors)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (FoldoutPresetEditorStateHeader(state))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 state.presetEditor.OnInspectorGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static bool FoldoutPresetEditorStateHeader(PresetEditorState state)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 state.expanded = EditorGUI.Foldout(r, state.expanded, state.presetEditor.target.name);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return state.expanded;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnDestroy()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Editor != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 DestroyImmediate(m_Editor);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Editor = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var state in m_RecordersEditors)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 DestroyImmediate(state.presetEditor);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecordersEditors.Clear();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 abstract class RecorderEditor : Editor
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0SerializedProperty m_CaptureEveryNthFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_FileNameGenerator;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_Take;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Texture2D s_SeparatorTexture;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly Color s_SeparatorColor = new Color(1.0f, 1.0f, 1.0f, 0.1f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static class Styles
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent FileNameLabel = new GUIContent("File Name");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent CaptureLabel = new GUIContent("Capture");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0internal static readonly GUIContent TakeNumberLabel = new GUIContent("Take Number");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent RenderStepFrameLabel = new GUIContent("Render Step Frame");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void OnEnable()
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var pf = new PropertyFinder<RecorderSettings>(serializedObject);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CaptureEveryNthFrame = pf.Find(w => w.captureEveryNthFrame);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FileNameGenerator = pf.Find(w => w.fileNameGenerator);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Take = pf.Find(w => w.take);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_SeparatorTexture = Resources.Load<Texture2D>("vertical_gradient");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void DrawSeparator()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 r.xMin -= 10.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 r.xMax += 10.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 r.yMin += 5.0f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 r.height = 10;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var orgColor = GUI.color;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.color = s_SeparatorColor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.DrawTexture(r, s_SeparatorTexture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.color = orgColor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnInspectorGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.Update();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FileTypeAndFormatGUI();
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 DrawSeparator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 NameAndPathGUI();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ImageRenderOptionsGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ExtraOptionsGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnEncodingGui();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.ApplyModifiedProperties();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.EndChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (GUI.changed)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ((RecorderSettings) target).SelfAdjustSettings();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnValidateSettingsGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void OnValidateSettingsGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var errors = new List<string>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!((RecorderSettings) target).ValidityCheck(errors))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var error in errors)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.HelpBox(error, MessageType.Warning);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void NameAndPathGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0EditorGUILayout.PropertyField(m_FileNameGenerator, Styles.FileNameLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Space();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_Take, Styles.TakeNumberLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EditorGUI.EndChangeCheck())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Take.intValue = Mathf.Max(0, m_Take.intValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void ImageRenderOptionsGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recorder = (RecorderSettings) target;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var inputsSetting in recorder.inputsSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var p = GetInputSerializedProperty(serializedObject, inputsSetting);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(p, Styles.CaptureLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static SerializedProperty GetInputSerializedProperty(SerializedObject owner, object fieldValue)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var targetObject = (object)owner.targetObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var type = targetObject.GetType();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var info in InputSettingsSelector.GetInputFields(type))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (info.GetValue(targetObject) == fieldValue)
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return owner.FindProperty(info.Name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (typeof(InputSettingsSelector).IsAssignableFrom(info.FieldType))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var selector = info.GetValue(targetObject);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var fields = InputSettingsSelector.GetInputFields(selector.GetType());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var selectorInput = fields.FirstOrDefault(i => i.GetValue(selector) == fieldValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selectorInput != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return owner.FindProperty(info.Name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void ExtraOptionsGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (((RecorderSettings)target).frameRatePlayback == FrameRatePlayback.Variable)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_CaptureEveryNthFrame, Styles.RenderStepFrameLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void FileTypeAndFormatGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void OnEncodingGui()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class RecorderInput : IDisposable
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderInputSettings settings \{ get; set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ~RecorderInput()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Dispose(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Dispose()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Dispose(true);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void Dispose(bool disposing)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GC.SuppressFinalize(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void SessionCreated(RecordingSession session) \{\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void BeginRecording(RecordingSession session) \{\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void NewFrameStarting(RecordingSession session) \{\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void NewFrameReady(RecordingSession session) \{\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void FrameDone(RecordingSession session) \{\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public virtual void EndRecording(RecordingSession session) \{\}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Experimental.UIElements;
\f1 \

\f0 using UnityEngine.Experimental.UIElements.StyleEnums;
\f1 \

\f0 using UnityObject = UnityEngine.Object;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class RecorderItem : VisualElement
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderSettings settings \{ get; private set; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public Editor editor \{ get; private set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly EditableLabel m_EditableLabel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly Toggle m_Toggle;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0readonly Texture2D m_RecorderIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Texture2D m_Icon;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public event Action<bool> OnEnableStateChanged;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static readonly Dictionary<string, Texture2D> s_IconCache = new Dictionary<string, Texture2D>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_Selected;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 bool m_Disabled;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetItemSelected(bool value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Selected = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AddToClassList("selected");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0RemoveFromClassList("selected");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void SetItemEnabled(RecorderControllerSettings prefs, bool value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Disabled = !value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings.enabled = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.Save();
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EditableLabel.SetLabelEnabled(value);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Toggle != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetToggleValue(m_Toggle, value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RemoveFromClassList("disabled");
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AddToClassList("disabled");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (OnEnableStateChanged != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnEnableStateChanged.Invoke(value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public enum State
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 None,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0Normal,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 HasWarnings,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 HasErrors
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 State m_State = State.None;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void UpdateState(bool checkForWarnings = true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settings == null || settings.HasErrors())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 state = State.HasErrors;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (checkForWarnings && settings.HasWarnings())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 state = State.HasWarnings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception e)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogWarning("Exception when getting recorder state: " + e);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 state = State.Normal;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public State state
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_State; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (value == State.None)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_State == value)
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (m_State)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case State.HasWarnings:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RemoveFromClassList("hasWarnings");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case State.HasErrors:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RemoveFromClassList("hasErrors");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case State.HasWarnings:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AddToClassList("hasWarnings");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Icon = StatusBarHelper.warningIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case State.HasErrors:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AddToClassList("hasErrors");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Icon = StatusBarHelper.errorIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case State.Normal:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Icon = m_RecorderIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_State = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0static Texture2D LoadIcon(string iconName)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (string.IsNullOrEmpty(iconName))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Texture2D icon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_IconCache.TryGetValue(iconName, out icon))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0return icon;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (EditorGUIUtility.isProSkin)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 icon = Resources.Load<Texture2D>("d_" + iconName);\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (icon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 icon = Resources.Load<Texture2D>(iconName);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_IconCache[iconName] = icon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return icon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderItem(RecorderControllerSettings prefs, RecorderSettings recorderSettings, string iconName)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings = recorderSettings;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settings != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 editor = Editor.CreateEditor(settings);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetFlex(this, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style.flexDirection = FlexDirection.Row;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Toggle = new Toggle(null);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Toggle.OnToggle(() =>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SetItemEnabled(prefs, UIElementHelper.GetToggleValue(m_Toggle));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \});
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_Toggle);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0m_RecorderIcon = LoadIcon(iconName);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_RecorderIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_RecorderIcon = LoadIcon("customrecorder_16");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UpdateState(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var iconContainer = new IMGUIContainer(() => // UIElement Image doesn't support tint yet. Use IMGUI instead.
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 r.width = r.height = Mathf.Max(r.width, r.height);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0var c = GUI.color;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var newColor = Color.white;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Disabled)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 newColor.a = 0.5f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!m_Selected)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 newColor.a = 0.8f;\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.color = newColor;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.DrawTexture(r, m_Icon);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GUI.color = c;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \});
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 iconContainer.AddToClassList("RecorderItemIcon");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 iconContainer.SetEnabled(false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(iconContainer);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EditableLabel = new EditableLabel \{ text = settings.name \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EditableLabel.OnValueChanged(newValue =>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings.name = newValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 prefs.Save();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \});
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_EditableLabel);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recorderEnabled = settings.enabled;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetToggleValue(m_Toggle, recorderEnabled);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SetItemEnabled(prefs, recorderEnabled);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void StartRenaming()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EditableLabel.StartEditing();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [AttributeUsage(AttributeTargets.Class, Inherited = false)]
\f1 \

\f0 \'a0\'a0\'a0 class RecorderSettingsAttribute : Attribute
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public readonly Type recorderType;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public readonly string displayName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public readonly string iconName;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderSettingsAttribute(Type recorderType, string displayName)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.recorderType = recorderType;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.displayName = displayName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecorderSettingsAttribute(Type recorderType, string displayName, string iconName)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.iconName = iconName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.recorderType = recorderType;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 this.displayName = displayName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomEditor(typeof(RecorderControllerSettings))]
\f1 \

\f0 \'a0\'a0\'a0 class RecorderSettingsPrefsEditor : Editor
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_RecordModeProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_PlaybackProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_FrameRateTypeProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_CustomFrameRateValueProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_StartFrameProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_EndFrameProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_StartTimeProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_EndTimeProperty;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedProperty m_CapFrameRateProperty;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GenericMenu m_FrameRateMenu;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static class Styles
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent RecordModeLabel = new GUIContent("Record Mode");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent SingleFrameLabel = new GUIContent("Frame");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent StartLabel = new GUIContent("Start");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent EndLabel = new GUIContent("End");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent FrameRateTitle\'a0\'a0 = new GUIContent("Frame Rate");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent PlaybackLabel\'a0\'a0\'a0 = new GUIContent("Playback");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent TargetFPSLabel\'a0\'a0 = new GUIContent("Target");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent MaxFPSLabel\'a0\'a0\'a0\'a0\'a0 = new GUIContent("Max");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent CapFPSLabel\'a0\'a0\'a0\'a0\'a0 = new GUIContent("Cap");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static readonly GUIContent ValueLabel\'a0\'a0\'a0\'a0\'a0\'a0 = new GUIContent("Value");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnEnable()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0m_RecordModeProperty = serializedObject.FindProperty("m_RecordMode");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_PlaybackProperty = serializedObject.FindProperty("m_FrameRatePlayback");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FrameRateTypeProperty\'a0 = serializedObject.FindProperty("m_FrameRateType");
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0m_CustomFrameRateValueProperty = serializedObject.FindProperty("m_CustomFrameRateValue");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartFrameProperty = serializedObject.FindProperty("m_StartFrame");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndFrameProperty = serializedObject.FindProperty("m_EndFrame");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartTimeProperty = serializedObject.FindProperty("m_StartTime");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndTimeProperty = serializedObject.FindProperty("m_EndTime");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_CapFrameRateProperty = serializedObject.FindProperty("m_CapFrameRate");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnInspectorGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RecordModeGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.Separator();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 FrameRateGUI();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool RecordModeGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.Update();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_RecordModeProperty, Styles.RecordModeLabel);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch ((RecordMode)m_RecordModeProperty.enumValueIndex)
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.Manual:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Nothing
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.SingleFrame:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var value = EditorGUILayout.IntField(Styles.SingleFrameLabel, m_StartFrameProperty.intValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartFrameProperty.intValue = Mathf.Max(value, 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.FrameInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var outputDimensions = new int[2];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions[0] = m_StartFrameProperty.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions[1] = m_EndFrameProperty.intValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (UIElementHelper.MultiIntField(GUIContent.none, new [] \{ Styles.StartLabel, Styles.EndLabel \}, 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartFrameProperty.intValue = Mathf.Max(outputDimensions[0], 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndFrameProperty.intValue = Mathf.Max(outputDimensions[1], m_StartFrameProperty.intValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.TimeInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var outputDimensions = new float[2];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions[0] = m_StartTimeProperty.floatValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0outputDimensions[1] = m_EndTimeProperty.floatValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (UIElementHelper.MultiFloatField(GUIContent.none, new [] \{ Styles.StartLabel, Styles.EndLabel \}, 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 outputDimensions))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_StartTimeProperty.floatValue = Mathf.Max(outputDimensions[0], 0);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_EndTimeProperty.floatValue = Mathf.Max(outputDimensions[1], m_StartTimeProperty.floatValue);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \} 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 --EditorGUI.indentLevel;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.ApplyModifiedProperties();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return GUI.changed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool FrameRateGUI()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.Update();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.LabelField(Styles.FrameRateTitle);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_PlaybackProperty, Styles.PlaybackLabel);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var variableFPS = m_PlaybackProperty.enumValueIndex == (int) FrameRatePlayback.Variable;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_FrameRateTypeProperty, variableFPS ? Styles.MaxFPSLabel : Styles.TargetFPSLabel);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_FrameRateTypeProperty.enumValueIndex == (int) FrameRateType.FR_CUSTOM)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ++EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_CustomFrameRateValueProperty, Styles.ValueLabel);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 --EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!variableFPS)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUILayout.PropertyField(m_CapFrameRateProperty, Styles.CapFPSLabel);\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 --EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 serializedObject.ApplyModifiedProperties();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return GUI.changed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEditor.Recorder.FrameCapturer;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class RecorderInfo
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public Type recorderType;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public Type settingsType;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string displayName;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public string iconName;
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 static class RecordersInventory
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Dictionary<Type, RecorderInfo> s_Recorders;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static HashSet<RecorderInfo> s_BuiltInRecorderInfos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static HashSet<RecorderInfo> s_LegacyRecorderInfos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static IEnumerable<KeyValuePair<Type, object[]>> FindRecorders()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var attribType = typeof(RecorderSettingsAttribute);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var a in AppDomain.CurrentDomain.GetAssemblies())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Type[] types;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 types = a.GetTypes();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogError( "Failed reflecting assembly: " + a.FullName );
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 continue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var t in types)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var attributes = t.GetCustomAttributes(attribType, false);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0if (attributes.Length != 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 yield return new KeyValuePair<Type, object[]>(t, attributes);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void Init()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_Recorders == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders = new Dictionary<Type, RecorderInfo>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var recorder in FindRecorders())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var settingsType = recorder.Key;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var settingsAttribs = recorder.Value;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settingsType == null || string.IsNullOrEmpty(settingsType.FullName))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 continue;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settingsAttribs.Length == 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var settingsAttrib = (RecorderSettingsAttribute) settingsAttribs[0];
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var info = new RecorderInfo
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settingsType = settingsType,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorderType = settingsAttrib.recorderType,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 displayName = settingsAttrib.displayName,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 iconName = settingsAttrib.iconName
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders.Add(settingsType, info);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_Recorders != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_BuiltInRecorderInfos == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_BuiltInRecorderInfos = new HashSet<RecorderInfo>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(AnimationRecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(MovieRecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(ImageRecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(GIFRecorderSettings)]
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_LegacyRecorderInfos == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_LegacyRecorderInfos = new HashSet<RecorderInfo>
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0s_Recorders[typeof(MP4RecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(EXRRecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(PNGRecorderSettings)],
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_Recorders[typeof(WEBMRecorderSettings)]
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static RecorderInfo GetRecorderInfo(Type settingsType)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settingsType == null || string.IsNullOrEmpty(settingsType.FullName))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_Recorders.ContainsKey(settingsType) ? s_Recorders[settingsType] : null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static IEnumerable<RecorderInfo> builtInRecorderInfos
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_BuiltInRecorderInfos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static IEnumerable<RecorderInfo> legacyRecorderInfos
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_LegacyRecorderInfos;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static IEnumerable<RecorderInfo> customRecorderInfos
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_Recorders.Values.Where(r => !s_BuiltInRecorderInfos.Contains(r) && !s_LegacyRecorderInfos.Contains(r));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static Recorder CreateDefaultRecorder(RecorderSettings recorderSettings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var factory = GetRecorderInfo(recorderSettings.GetType());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (factory != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recorder = (Recorder)ScriptableObject.CreateInstance(factory.recorderType);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.Reset();
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0recorder.settings = recorderSettings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return recorder;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentException("No factory was registered for " + recorderSettings.GetType().Name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static RecorderSettings CreateDefaultRecorderSettings(Type settingsType)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Init();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var recorderinfo = GetRecorderInfo(settingsType);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (recorderinfo != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var settings = (RecorderSettings)ObjectFactory.CreateInstance(recorderinfo.settingsType);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings.name = settingsType.Name;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return settings;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentException("No factory was registered for " + settingsType.Name);\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class RecordingSession : IDisposable
\f1 \

\f0 \'a0\'a0\'a0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal Recorder recorder;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal GameObject recorderGameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal RecorderComponent recorderComponent;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int m_FrameIndex = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int m_InitialFrame = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int m_FirstRecordedFrameCount = -1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float m_FPSTimeStart;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 float m_FPSNextTimeStart;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 int m_FPSNextFrameCount;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal double currentFrameStartTS \{ get; private set; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal double recordingStartTS \{ get; private set; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal DateTime sessionStartTS \{ get; private set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0internal RecorderSettings settings
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return recorder.settings; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool isRecording
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return recorder.recording; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal int frameIndex
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_FrameIndex; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal int RecordedFrameSpan
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_FirstRecordedFrameCount == -1 ? 0 : Time.renderedFrameCount - m_FirstRecordedFrameCount; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal float recorderTime
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return (float)(currentFrameStartTS - settings.startTime); \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void AllowInBackgroundMode()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!Application.runInBackground)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0Application.runInBackground = true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log("Recording sessions is enabling Application.runInBackground!");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool SessionCreated()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AllowInBackgroundMode();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recordingStartTS = (Time.time / Time.timeScale);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sessionStartTS = DateTime.Now;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SessionCreated(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return true;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception ex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogException(ex);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal bool BeginRecording()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!settings.isPlatformSupported)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogError(string.Format("Recorder \{0\} does not support current platform", recorder.GetType().Name));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AllowInBackgroundMode();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recordingStartTS = (Time.time / Time.timeScale);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SignalInputsOfStage(ERecordingSessionStage.BeginRecording, this);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!recorder.BeginRecording(this))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_InitialFrame = Time.renderedFrameCount;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FPSTimeStart = Time.unscaledTime;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return true;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception ex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Debug.LogException(ex);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void EndRecording()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!isRecording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SignalInputsOfStage(ERecordingSessionStage.EndRecording, this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.EndRecording(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception ex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogException(ex);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void RecordFrame()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SignalInputsOfStage(ERecordingSessionStage.NewFrameReady, this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!recorder.SkipFrame(this))
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.RecordFrame(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.recordedFramesCount++;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (recorder.recordedFramesCount == 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FirstRecordedFrameCount = Time.renderedFrameCount;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SignalInputsOfStage(ERecordingSessionStage.FrameDone, this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception ex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogException(ex);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Note: This is not great when multiple recorders are simultaneously active...
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (settings.frameRatePlayback == FrameRatePlayback.Variable ||
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 settings.frameRatePlayback == FrameRatePlayback.Constant && recorder.settings.capFrameRate)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var frameCount = Time.renderedFrameCount - m_InitialFrame;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var frameLen = 1.0f / recorder.settings.frameRate;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var elapsed = Time.unscaledTime - m_FPSTimeStart;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var target = frameLen * (frameCount + 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sleep = (int)((target - elapsed) * 1000);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (sleep > 2)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(string.Format("Recording session info => dT: \{0:F1\}s, Target dT: \{1:F1\}s, Retarding: \{2\}ms, fps: \{3:F1\}", elapsed, target, sleep, frameCount / elapsed));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 System.Threading.Thread.Sleep(Math.Min(sleep, 1000));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else if (sleep < -frameLen)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_InitialFrame--;
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0else if (Options.verboseMode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.Log(string.Format("Recording session info => fps: \{0:F1\}", frameCount / elapsed));
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // reset every 30 frames
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (frameCount % 50 == 49)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FPSNextTimeStart = Time.unscaledTime;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FPSNextFrameCount = Time.renderedFrameCount;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (frameCount % 100 == 99)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FPSTimeStart = m_FPSNextTimeStart;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_InitialFrame = m_FPSNextFrameCount;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_FrameIndex++;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void PrepareNewFrame()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 try
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 AllowInBackgroundMode();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 currentFrameStartTS = (Time.time / Time.timeScale) - recordingStartTS;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.SignalInputsOfStage(ERecordingSessionStage.NewFrameStarting, this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder.PrepareNewFrame(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 catch (Exception ex)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Debug.LogException(ex);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Dispose()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (recorder != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EndRecording();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UnityHelpers.Destroy(recorder);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [CustomPropertyDrawer(typeof(RecordMode))]
\f1 \

\f0 \'a0\'a0\'a0 class RecordModePropertyDrawer : EnumProperyDrawer<RecordMode>
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0protected override string ToLabel(RecordMode value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.Manual:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "Manual";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.SingleFrame:
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return "Single Frame";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.FrameInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "Frame Interval";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.TimeInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "Time Interval (sec)";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 default:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return "unknown";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Recorder;
\f1 \

\f0 using UnityEngine.SceneManagement;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class BindingManager
\f1 \

\f0 \'a0\'a0\'a0 \{\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 const string k_HostGoName = "Unity-RecorderBindings";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static Object Get(string id)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rcs = FindRecorderBindings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rc = rcs.FirstOrDefault(r => r.HasBindingValue(id));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return rc != null ? rc.GetBindingValue(id) : null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static void Duplicate(string id, string newId)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0var rcs = FindRecorderBindings();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var rc in rcs)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rc.DuplicateBinding(id, newId);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static void Set(string id, Object obj)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rbs = FindRecorderBindings();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (obj == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Remove
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var rb in rbs)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RemoveBinding(id, rb);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var scene = GetObjectScene(obj);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rb = rbs.FirstOrDefault(r => r.gameObject.scene == scene);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (rb == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Add
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var gameObject = UnityHelpers.CreateRecorderGameObject(k_HostGoName);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rb = gameObject.AddComponent<RecorderBindings>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SceneManager.MoveGameObjectToScene(rb.gameObject, scene);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // Replace
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rb.SetBindingValue(id, obj);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var r in rbs)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (r == rb)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 continue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RemoveBinding(id, r);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void RemoveBinding(string id, RecorderBindings rb)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rb.RemoveBinding(id);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (rb.IsEmpty())
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Object.DestroyImmediate(rb.gameObject);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static RecorderBindings[] FindRecorderBindings()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return Object.FindObjectsOfType<RecorderBindings>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Scene GetObjectScene(Object obj)
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var gameObject = obj as GameObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (gameObject != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return gameObject.scene;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var component = obj as Component;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (component != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return component.gameObject.scene;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return SceneManager.GetActiveScene();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 class SceneHook
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 const string k_HostGoName = "Unity-RecorderSessions";
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GameObject s_SessionHooksRoot;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly string m_SessionId;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GameObject m_SessionHook;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public SceneHook(string sessionId)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_SessionId = sessionId;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GameObject GetSessionHooksRoot(bool createIfNecessary = true)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_SessionHooksRoot == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_SessionHooksRoot = GameObject.Find(k_HostGoName);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_SessionHooksRoot == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!createIfNecessary)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_SessionHooksRoot = UnityHelpers.CreateRecorderGameObject(k_HostGoName);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_SessionHooksRoot;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 GameObject GetSessionHook()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_SessionHook != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_SessionHook;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var host = GetSessionHooksRoot();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (host == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_SessionHook = GameObject.Find(m_SessionId);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_SessionHook == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_SessionHook = new GameObject(m_SessionId);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_SessionHook.transform.parent = host.transform;\'a0\'a0 
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_SessionHook;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public IEnumerable<RecordingSession> GetRecordingSessions()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sessionHook = GetSessionHook();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (sessionHook != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0var components = sessionHook.GetComponents<RecorderComponent>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var component in components)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 yield return component.session;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0public static void PrepareSessionRoot()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var host = GetSessionHooksRoot();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (host != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 host.hideFlags = HideFlags.None;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Object.DontDestroyOnLoad(host);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecordingSession CreateRecorderSessionWithRecorderComponent(RecorderSettings settings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var component = GetRecorderComponent(settings);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var session = new RecordingSession
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder = RecordersInventory.CreateDefaultRecorder(settings),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorderGameObject = component.gameObject,
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorderComponent = component
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 component.session = session;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return session;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecordingSession CreateRecorderSession(RecorderSettings settings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sceneHook = GetSessionHook();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (sceneHook == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var session = new RecordingSession
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorder = RecordersInventory.CreateDefaultRecorder(settings),
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recorderGameObject = sceneHook
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return session;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 RecorderComponent GetRecorderComponent(RecorderSettings settings)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sceneHook = GetSessionHook();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (sceneHook == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return null;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var component = sceneHook.GetComponentsInChildren<RecorderComponent>().FirstOrDefault(r => r.session.settings == settings);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (component == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 component = sceneHook.AddComponent<RecorderComponent>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return component;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Reflection;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class TargetedPropertyDrawer<T> : PropertyDrawer where T : class
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected T target;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected virtual void Initialize(SerializedProperty prop)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (target == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var path = prop.propertyPath.Split('.');
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 object obj = prop.serializedObject.targetObject;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var pathNode in path)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 obj = GetSerializedField(obj, pathNode).GetValue(obj);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 target = obj as T;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static FieldInfo GetSerializedField(object target, string pathNode)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return target.GetType().GetField(pathNode, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 class TextureFlipper : IDisposable
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0RenderTexture m_WorkTexture;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void Flip(RenderTexture target)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_WorkTexture == null || m_WorkTexture.width != target.width || m_WorkTexture.height != target.height)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UnityHelpers.Destroy(m_WorkTexture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_WorkTexture = new RenderTexture(target);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var sRGBWrite = GL.sRGBWrite;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GL.sRGBWrite = PlayerSettings.colorSpace == ColorSpace.Linear;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Graphics.Blit(target, m_WorkTexture, new Vector2(1.0f, -1.0f), new Vector2(0.0f, 1.0f));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Graphics.Blit(m_WorkTexture, target);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 GL.sRGBWrite = sRGBWrite;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Dispose()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UnityHelpers.Destroy(m_WorkTexture);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_WorkTexture = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Experimental.UIElements;
\f1 \

\f0 using UnityEngine.Experimental.UIElements.StyleEnums;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0 class VisualListItem<T> : VisualElement where T : VisualElement
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public event Action OnSelectionChanged;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public event Action OnContextMenu;
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0public event Action<T> OnItemContextMenu;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public event Action<T> OnItemRename;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 [Serializable]
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 class Selection
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int index = -1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Selection m_Selection;
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public int selectedIndex
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_Selection != null ? m_Selection.index : 0; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_Selection == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Selection.index = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (OnSelectionChanged != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnSelectionChanged.Invoke();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 SavePersistentData();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly ScrollView m_ScrollView;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 readonly List<T> m_ItemsCache = new List<T>();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 protected VisualListItem()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView = new ScrollView
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 style =
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 flexDirection = FlexDirection.Column
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 UIElementHelper.SetFlex(m_ScrollView, 1.0f);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView.contentContainer.style.positionLeft = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView.contentContainer.style.positionRight = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(m_ScrollView);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RegisterCallback<MouseUpEvent>(OnMouseUp);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Reload(IEnumerable<T> itemList)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView.Clear();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ItemsCache.Clear();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selectedIndex = -1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 foreach (var item in itemList)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Add(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selection = m_ItemsCache.FirstOrDefault();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0public List<T> items
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get \{ return m_ItemsCache; \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public T selection
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(selectedIndex < 0 || selectedIndex > m_ItemsCache.Count - 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0return null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_ItemsCache[selectedIndex];
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 set
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selection == value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selectedIndex = m_ItemsCache.IndexOf(value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Add(T item)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 item.RegisterCallback<MouseDownEvent>(OnItemMouseDown);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 item.RegisterCallback<MouseUpEvent>(OnItemMouseUp);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView.Add(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ItemsCache.Add(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Remove(T item)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var selected = selection == item;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ScrollView.Remove(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_ItemsCache.Remove(item);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selected)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selectedIndex = Math.Min(selectedIndex, items.Count - 1);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnMouseUp(MouseUpEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.clickCount != 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.button == (int) MouseButton.RightMouse)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (OnContextMenu != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnContextMenu.Invoke();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public bool HasFocus()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return focusController.focusedElement == this;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnItemMouseDown(MouseDownEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.clickCount != 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.button != (int) MouseButton.LeftMouse && evt.button != (int) MouseButton.RightMouse)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var item = (T) evt.currentTarget;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.modifiers == EventModifiers.None)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var alreadySelected = selection == item;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.button == (int) MouseButton.LeftMouse && alreadySelected)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (HasFocus() && OnItemRename != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0OnItemRename.Invoke(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selection = item;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 void OnItemMouseUp(MouseUpEvent evt)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.clickCount != 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (evt.modifiers != EventModifiers.None || evt.button != (int) MouseButton.RightMouse)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0if (OnItemContextMenu != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var item = (T) evt.currentTarget;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnItemContextMenu.Invoke(item);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 evt.StopImmediatePropagation();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnPersistentDataReady()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 base.OnPersistentDataReady();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var key = GetFullHierarchicalPersistenceKey();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Selection = GetOrCreatePersistentData<Selection>(m_Selection, key);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (OnSelectionChanged != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnSelectionChanged.Invoke();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 using System.Collections;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 [ExecuteInEditMode]
\f1 \

\f0 \'a0\'a0\'a0 class RecorderComponent : MonoBehaviour
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public RecordingSession session \{ get; set; \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void Update()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session != null && session.isRecording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 session.PrepareNewFrame();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 IEnumerator RecordFrame()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 yield return new WaitForEndOfFrame();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session != null && session.isRecording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 session.RecordFrame();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switch (session.recorder.settings.recordMode)
\f1 \

\f0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.Manual:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.SingleFrame:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session.recorder.recordedFramesCount == 1)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.FrameInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session.frameIndex > session.settings.endFrame)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 case RecordMode.TimeInterval:
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session.settings.frameRatePlayback == FrameRatePlayback.Variable)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session.currentFrameStartTS >= session.settings.endTime)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0var expectedFrames = (session.settings.endTime - session.settings.startTime) * session.settings.frameRate;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session.RecordedFrameSpan >= expectedFrames)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 enabled = false;
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 break;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void LateUpdate()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session != null && session.isRecording)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 StartCoroutine(RecordFrame());
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void OnDisable()
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 session.Dispose();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 session = null;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public void OnDestroy()
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (session != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 session.Dispose();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System;
\f1 \

\f0 using System.Collections.Generic;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class EnumHelper
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static int GetEnumValueFromMaskedIndex<TEnum>(int index, int mask)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!typeof(TEnum).IsEnum) throw new ArgumentException("Arg not an enum");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var values = Enum.GetValues(typeof(TEnum));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for( int i = 0, j = -1; i < values.Length; i++ )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (((int)values.GetValue(i) & mask) != 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 j++;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (j == index)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return (int)values.GetValue(i);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 throw new ArgumentException("invalid masked index");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static int GetMaskedIndexFromEnumValue<TEnum>(int value, int mask)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!typeof(TEnum).IsEnum) throw new ArgumentException("Arg not an enum");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var values = Enum.GetValues(typeof(TEnum));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for( int i = 0, j = -1; i < values.Length; i++ )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var v = (int)values.GetValue(i);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if ((v & mask) != 0)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 j++;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0if (v == value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return j;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static string[] MaskOutEnumNames<TEnum>(int mask )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (!typeof(TEnum).IsEnum) throw new ArgumentException("Arg not an enum");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var names = Enum.GetNames(typeof(TEnum));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var values = Enum.GetValues(typeof(TEnum));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var result = new List<String>();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for( int i = 0; i < values.Length; i++ )
\f1 \

\f0 \'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if( ((int)values.GetValue(i) & mask ) != 0 )
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 result.Add( (string)names.GetValue(i) );
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return result.ToArray();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using UnityEditor.Presets;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class PresetHelper
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Texture2D s_PresetIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GUIStyle s_PresetButtonStyle;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static Texture2D presetIcon
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_PresetIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_PresetIcon = (Texture2D) EditorGUIUtility.Load(EditorGUIUtility.isProSkin ? "d_Preset.Context" : "Preset.Context");
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_PresetIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static GUIStyle presetButtonStyle
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_PresetButtonStyle ?? (s_PresetButtonStyle = new GUIStyle("iconButton") \{ fixedWidth = 19.0f \});
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal class PresetReceiver : PresetSelectorReceiver
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 RecorderSettings m_Target;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Preset m_InitialValue;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Action m_OnSelectionChanged;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Action m_OnSelectionClosed;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal void Init(RecorderSettings target, Action onSelectionChanged = null, Action onSelectionClosed = null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnSelectionChanged = onSelectionChanged;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnSelectionClosed = onSelectionClosed;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0m_Target = target;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_InitialValue = new Preset(target);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnSelectionChanged(Preset selection)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (selection != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0Undo.RecordObject(m_Target, "Apply Preset " + selection.name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 selection.ApplyTo(m_Target);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 Undo.RecordObject(m_Target, "Cancel Preset");
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0m_InitialValue.ApplyTo(m_Target);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_OnSelectionChanged != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnSelectionChanged.Invoke();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 public override void OnSelectionClosed(Preset selection)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 OnSelectionChanged(selection);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Target.OnAfterDuplicate();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (m_OnSelectionClosed != null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_OnSelectionClosed.Invoke();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 DestroyImmediate(this);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 using System;
\f1 \

\f0 using System.Linq.Expressions;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class SerializableObjHelper
\f1 \

\f0 \'a0\'a0\'a0 \{\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static SerializedProperty FindPropertyRelative(this SerializedProperty obj, Expression<Func<object>> exp)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var body = exp.Body as MemberExpression;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (body == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ubody = (UnaryExpression)exp.Body;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 body = ubody.Operand as MemberExpression;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var name = body.Member.Name;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return obj.FindPropertyRelative(name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 class PropertyFinder<TType> where TType : class
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 SerializedObject m_Obj;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public PropertyFinder(SerializedObject obj)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 m_Obj = obj;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public delegate TResult FuncX<TResult>(TType x);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public SerializedProperty Find( Expression<FuncX<object>> exp)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var body = exp.Body as MemberExpression;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (body == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var ubody = (UnaryExpression)exp.Body;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 body = ubody.Operand as MemberExpression;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var name = body.Member.Name;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return m_Obj.FindProperty(name);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using UnityEngine;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class StatusBarHelper
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Texture2D s_ErrorIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Texture2D s_WarningIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static Texture2D s_InfoIcon;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GUIStyle s_ErrorStyle;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GUIStyle s_WarningStyle;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static GUIStyle s_InfoStyle;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static Texture2D errorIcon
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_ErrorIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_ErrorIcon = EditorGUIUtility.Load("Icons/console.erroricon.sml.png") as Texture2D;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_ErrorIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static Texture2D warningIcon
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_WarningIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_WarningIcon = EditorGUIUtility.Load("Icons/console.warnicon.sml.png") as Texture2D;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0return s_WarningIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static Texture2D infoIcon
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if (s_InfoIcon == null)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 s_InfoIcon = EditorGUIUtility.Load("Icons/console.infoicon.sml.png") as Texture2D;
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_InfoIcon;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static GUIStyle errorStyle
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_ErrorStyle ?? (s_ErrorStyle = new GUIStyle("CN StatusError"));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static GUIStyle warningStyle
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_WarningStyle ?? (s_WarningStyle = new GUIStyle("CN StatusWarn"));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 public static GUIStyle infoStyle
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 get
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return s_InfoStyle ?? (s_InfoStyle = new GUIStyle("CN StatusInfo"));
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \uc0\u1087 \u1111 \u1114 using System.Collections.Generic;
\f1 \

\f0 using System.Linq;
\f1 \

\f0 using UnityEngine;
\f1 \

\f0 using UnityEngine.Experimental.UIElements;
\f1 \

\f0 \'a0
\f1 \

\f0 namespace UnityEditor.Recorder
\f1 \

\f0 \{
\f1 \

\f0 \'a0\'a0\'a0 static class UIElementHelper
\f1 \

\f0 \'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static void SetFlex(VisualElement element, float value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0#if UNITY_2018_3_OR_NEWER
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 element.style.flex = new Flex(value);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 element.style.flex = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endif
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static bool GetToggleValue(Toggle toggle)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #if UNITY_2018_2_OR_NEWER
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return toggle.value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return toggle.on;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endif
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static void SetToggleValue(Toggle toggle, bool value)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0\'a0#if UNITY_2018_2_OR_NEWER
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 toggle.value = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #else
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 toggle.on = value;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 #endif
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static bool MultiIntField(GUIContent label, GUIContent[] subLabels, int[] values)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rLabel = r;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rLabel.width = EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.LabelField(rLabel, label);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rContent = r;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0rContent.xMin = rLabel.xMax;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var width = subLabels.Select(l => GUI.skin.label.CalcSize(l).x).Max();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 MultiIntField(rContent, subLabels, values, width);
\f1 \

\f0 \'a0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return EditorGUI.EndChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 internal static bool MultiFloatField(GUIContent label, GUIContent[] subLabels, float[] values)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var r = EditorGUILayout.GetControlRect();
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rLabel = r;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rLabel.width = EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.LabelField(rLabel, label);
\f1 \

\f0 \'a0
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var rContent = r;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 rContent.xMin = rLabel.xMax;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var width = subLabels.Select(l => GUI.skin.label.CalcSize(l).x).Max();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.BeginChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 MultiFloatField(rContent, subLabels, values, width);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return EditorGUI.EndChangeCheck();
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void MultiIntField(Rect position, IList<GUIContent> subLabels, IList<int> values, float labelWidth)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var length = values.Count;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var num = (position.width - (float) (length - 1) * 2f) / (float) length;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var position1 = new Rect(position)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 width = num
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var labelWidth1 = EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var indentLevel = EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for (int index = 0; index < values.Count; ++index)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 values[index] = EditorGUI.IntField(position1, subLabels[index], values[index]);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 position1.x += num + 2f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = labelWidth1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 static void MultiFloatField(Rect position, IList<GUIContent> subLabels, IList<float> values, float labelWidth)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var length = values.Count;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var num = (position.width - (float) (length - 1) * 2f) / (float) length;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var position1 = new Rect(position)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 width = num
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \};
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var labelWidth1 = EditorGUIUtility.labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 var indentLevel = EditorGUI.indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = labelWidth;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUI.indentLevel = 0;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 for (int index = 0; index < values.Count; ++index)
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 values[index] = EditorGUI.FloatField(position1, subLabels[index], values[index]);
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 position1.x += num + 2f;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 EditorGUIUtility.labelWidth = labelWidth1;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0EditorGUI.indentLevel = indentLevel;
\f1 \

\f0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1 \

\f0 \'a0\'a0\'a0 \}
\f1 \

\f0 \}
\f1 \

\f0 \'a0
\f1 \
}